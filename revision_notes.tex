\documentclass[10pt,a4paper,twocolumn]{article}

\usepackage[margin=1.4cm]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{float}
\usepackage{graphicx}

% Tighter section spacing and slightly smaller titles
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{3pt}{1pt}
\titleformat{\section}{\small\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\small\bfseries}{\thesubsection}{0.5em}{}

\setlength{\parskip}{2pt}
\setlength{\parindent}{0pt}
\setlist{noitemsep,topsep=1pt,leftmargin=*}

\date{}

\begin{document}
\small

\section{Week 1}

\subsection{Why Study Blockchains}

\textbf{High level idea:} Blockchains are a new paradigm for distributed secure systems.

They combine:
\begin{itemize}
  \item Cryptography (hashes, signatures, PoW).
  \item Distributed systems (consensus, P2P networks).
  \item Economics and game theory (incentives, equilibria).
\end{itemize}

Why they matter:
\begin{itemize}
  \item Help understand modern security mechanisms:
  \begin{itemize}
    \item Key management and PKI.
    \item Software integrity and update mechanisms.
    \item Privacy enhancing technologies.
  \end{itemize}
  \item Enable new organizational forms:
  \begin{itemize}
    \item Cryptocurrency and DeFi.
    \item DAOs, on chain governance.
    \item Token based coordination and funding.
  \end{itemize}
  \item Bitcoin is a concrete proof that a large scale open system can run for years without a central operator.
\end{itemize}

\subsection{Blockchains and Distributed Ledgers}

\subsubsection{Concepts}

\textbf{Blockchain:} a distributed, append only data structure that maintains a consistent log of transactions across many nodes.

\textbf{Distributed ledger:} a general term for systems that maintain shared state among multiple parties without a single trusted authority.

Desired properties:
\begin{itemize}
  \item \textbf{Safety:} all honest nodes agree on the same history (no conflicting logs).
  \item \textbf{Liveness:} valid transactions are eventually included and confirmed.
\end{itemize}

Bitcoin is the first widely deployed blockchain protocol that achieves these properties in a permissionless setting.

\subsection{Endless Ledger Parable}

\subsubsection{Book and Scribes}

Intuition: model Bitcoin as an endlessly growing ledger maintained by many \emph{scribes}.

\begin{itemize}
  \item There is a shared ledger (a book) with many numbered pages.
  \item Anyone can become a scribe and propose a new page.
  \item Each page records a batch of transactions.
  \item The ledger never stops growing: new pages are added over time.
\end{itemize}

Constraint: adding a page requires expensive work.

\begin{itemize}
  \item To write page \(i\), the scribe must solve a hard puzzle, like throwing many dice until a rare pattern appears.
  \item This represents Proof of Work (PoW).
\end{itemize}

\subsubsection{Forks and Longest Chain Rule}

Multiple copies of the ledger may exist:

\begin{itemize}
  \item Different scribes work in parallel and may produce conflicting next pages.
  \item Question: which ledger is the ``correct'' one?
\end{itemize}

\textbf{Rule:} everyone follows the ledger with the largest number of valid pages.

\begin{itemize}
  \item If several ledgers have the same maximum length, pick the first one you received and keep writing on top of it.
  \item Pages not on the longest ledger become \emph{orphan} pages.
\end{itemize}

This is the \textbf{longest chain rule}: choose the chain with the greatest cumulative work.

\subsubsection{Randomness and Symmetry Breaking}

Each page is produced by a random process (dice throwing, PoW search):

\begin{itemize}
  \item With many scribes, the chances that two of them keep finding pages in perfect lockstep are tiny.
  \item Eventually one scribe gets ahead, creating a longer ledger.
  \item Other scribes then switch to this longer ledger.
\end{itemize}

Randomness breaks symmetry and lets the system converge on a single chain.

\subsubsection{Incentives for Scribes}

To motivate scribes to do the costly work:

\begin{itemize}
  \item The rules allow the scribe who creates a valid new page to insert a special record awarding them a reward.
  \item In Bitcoin this is the block reward (newly minted coins) plus transaction fees.
\end{itemize}

Key points:
\begin{itemize}
  \item Anyone with computing resources can become a miner.
  \item More computing power implies higher probability of winning the next block.
\end{itemize}

\subsection{Scalable Service Provision Problem}

General IT question:

\textbf{How can we scale an online service to the whole world when participants do not trust each other and there is no central authority?}

Traditional answers:
\begin{itemize}
  \item \textbf{Federation:} multiple providers cooperate (e.g. email, XMPP).
  \item \textbf{Centralization:} one dominant provider (e.g. large social networks, cloud services).
\end{itemize}

Blockchains show a third option: decentralized provision by \emph{resource owners} instead of fixed organizations.

\subsubsection{Software Only Launch (SOL)}

Goal: deploy a system purely by publishing software.

\begin{itemize}
  \item Release an open source program.
  \item Announce a start time.
  \item Anyone can download the program and run it.
  \item When enough nodes run the software, the system ``self boots'' and becomes operational.
\end{itemize}

Bitcoin is a successful example of such a software only launch.

\subsection{Hash Functions}

\subsubsection{Definition and Basic Properties}

A hash function \(H\) maps inputs of arbitrary length to fixed length outputs.

Requirements:
\begin{itemize}
  \item Efficient to compute.
  \item Output looks random and is well spread over the output space.
\end{itemize}

Cryptographic security properties:
\begin{itemize}
  \item \textbf{Pre image resistance:} given \(y\), it is hard to find any \(x\) with \(H(x) = y\).
  \item \textbf{Second pre image resistance:} given \(x\), it is hard to find \(x' \neq x\) with \(H(x') = H(x)\).
  \item \textbf{Collision resistance:} it is hard to find any pair \(x \neq x'\) such that \(H(x) = H(x')\).
\end{itemize}

\subsubsection{Birthday Paradox}

If there are \(n\) possible hash outputs, collisions appear surprisingly early.

\begin{itemize}
  \item Approximate number of random samples needed for a collision with probability \(\approx 50\%\): \(k \approx 1.177 \sqrt{n}\).
  \item For hash outputs of \(t\) bits, \(n = 2^t\), so attacks based on collisions cost about \(2^{t/2}\) operations.
\end{itemize}

\subsubsection{Examples}

\begin{itemize}
  \item Broken: MD5, SHA 1 (known collisions).
  \item Current families: SHA 2 and SHA 3 with 224, 256, 384, 512 bit outputs.
  \item Bitcoin uses SHA 256 (from SHA 2 family).
\end{itemize}

\subsection{Digital Signatures}

\subsubsection{API}

A signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\):

\begin{itemize}
  \item \textbf{KeyGen}:
  \[
    (sk, vk) \leftarrow \text{KeyGen}(1^\lambda)
  \]
  where \(sk\) is the secret signing key, \(vk\) is the public verification key.
  \item \textbf{Sign}:
  \[
    \sigma \leftarrow \text{Sign}(sk, m)
  \]
  where \(m\) is the message.
  \item \textbf{Verify}:
  \[
    b \leftarrow \text{Verify}(vk, m, \sigma) \in \{0,1\}
  \]
  output 1 (accept) or 0 (reject).
\end{itemize}

\subsubsection{Security Intuition}

Existential unforgeability under chosen message attack (EU CMA):

\begin{itemize}
  \item Attacker can obtain signatures on messages of their choice from a signing oracle.
  \item Even with this advantage, attacker should not be able to produce a valid signature on a new message that was never signed before.
\end{itemize}

\subsubsection{Constructions}

\begin{itemize}
  \item Based on RSA (integer factorization hard).
  \item Based on discrete logarithms (DSA).
  \item Elliptic curve variants (ECDSA, Schnorr).
\end{itemize}

Bitcoin uses ECDSA originally and later also supports Schnorr style signatures.

\subsection{Proof of Work (PoW)}

\subsubsection{Definition}

A PoW scheme allows a prover to demonstrate that a certain amount of computational work has been done.

Typical hash based PoW:

\[
  \text{Find } w \text{ such that } H(\text{data} \Vert w) \le T
\]
where \(T\) is a difficulty target.

\subsubsection{Simple Algorithm}

\begin{verbatim}
ctr = 0
while H(data || ctr) > T:
    ctr = ctr + 1
return ctr
\end{verbatim}

Properties:
\begin{itemize}
  \item \textbf{Fast verification:} given \(w\), one hash evaluation checks whether the condition holds.
  \item \textbf{No shortcuts:} for a well designed hash function, there is no significantly faster way than brute forcing different \(w\).
\end{itemize}

\subsubsection{Variants}

\begin{itemize}
  \item Standard Hashcash style PoW (used in Bitcoin).
  \item Memory hard PoW (e.g. scrypt, Equihash) to force large RAM usage.
  \item ASIC resistant PoW to reduce the advantage of specialized hardware.
\end{itemize}

\subsection{Resource Based Systems}

\subsubsection{Resource Types}

In resource based systems participation is tied to control of some scarce resource:

\begin{itemize}
  \item \textbf{Proof of Work (PoW):} computational power.
  \item \textbf{Proof of Stake (PoS):} ownership of currency or tokens.
  \item \textbf{Proof of Space / Capacity:} available storage.
  \item \textbf{Proof of Time / Identity:} trusted hardware or other timing assumptions.
\end{itemize}

The system is not pinned to a fixed set of identities. Instead, any entity that can show a valid proof of resource can participate in maintaining the ledger.

\subsubsection{PoW vs PoS}

\textbf{PoW:}
\begin{itemize}
  \item Pros: simple design, well studied, direct link between cost and security.
  \item Cons: high energy usage, hardware centralization (ASIC farms), environmental concerns.
\end{itemize}

\textbf{PoS:}
\begin{itemize}
  \item Pros: lower energy usage, security based on economic value at stake.
  \item Cons: subtle security issues (nothing at stake, long range attacks), more complex protocol design.
\end{itemize}

\subsection{Tokenomics}

\subsubsection{Basic Idea}

Tokenomics studies how to use tokens and rewards to align incentives of participants.

Typical cycle:
\begin{itemize}
  \item Users pay fees to use the service (transactions, smart contracts).
  \item The protocol distributes rewards to resource providers (miners, validators).
  \item Providers sell some of their tokens to cover costs and profit.
\end{itemize}

Goal: set parameters so that:
\begin{itemize}
  \item Providing honest service is economically attractive.
  \item Attacking or misbehaving is economically disfavored.
\end{itemize}

\subsection{Decentralized Service Provision}

To run a decentralized service in an open network, the protocol must handle:

\begin{itemize}
  \item \textbf{DoS resistance:} prevent abuse by spamming transactions or connections.
  \item \textbf{Consistency:} all honest participants eventually agree on the same state.
  \item \textbf{Liveness and censorship resistance:} valid transactions should not be permanently excluded.
  \item \textbf{Fairness of rewards:} contributions of resource providers should be measured and rewarded in a predictable way.
\end{itemize}

\subsubsection{Reward Sharing}

Rewards can be distributed:
\begin{itemize}
  \item Per block or per action (e.g. each mined block gets a fixed reward).
  \item Per epoch (e.g. aggregate rewards over a time window then share according to contribution).
\end{itemize}

Design challenge:
\begin{itemize}
  \item Ensure that rational, self interested participants collectively form a robust and secure system.
  \item Avoid centralization and cartel behavior where possible.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Blockchains provide a new way to build global services without central operators.
  \item The ``endless ledger'' parable explains how longest chain and randomness yield consensus.
  \item Hash functions and digital signatures are the basic cryptographic tools for integrity and authenticity.
  \item Proof of Work ties block production to computational effort and is easy to verify.
  \item Resource based systems use PoW, PoS, or other proofs to select and reward maintainers.
  \item Tokenomics and reward sharing mechanisms align incentives so that honest behavior is profitable.
\end{itemize}

\section{Week2}
\subsection{Authenticated File Storage}

\textbf{Goal:} Store a file on an untrusted server but keep only a short local state 
so that later you can check whether the server returned the correct data.

Client has identifier \(F\) and data \(D\). It sends \((F,D)\) to the server, 
and wants to delete \(D\) locally while still being able to verify any future response from the server.

\subsubsection{Naive solution (does not help)}

Client keeps a full local copy of \(D\) and checks equality with any \(D'\) returned by the server. 
This gives integrity but saves no storage.

\subsection{Basic Cryptographic Tools}

\subsubsection{Hash-based authentication}

Hash function \(H\) is collision resistant.

\begin{itemize}
  \item Upload: client sends \((F,D)\) to server.
  \item Commit: client stores only \(h = H(D)\), deletes \(D\).
  \item Retrieval: server returns \(D'\).
  \item Verify: client accepts if \(H(D') = h\), rejects otherwise.
\end{itemize}

Properties:
\begin{itemize}
  \item Client keeps a short fixed-size value.
  \item Integrity relies on collision resistance of \(H\).
\end{itemize}

\subsubsection{Digital signatures}

Signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\).

\begin{itemize}
  \item Key generation: client runs \(\text{KeyGen}\) to get \((sk, vk)\).
  \item Upload: compute \(\sigma = \text{Sign}(sk,\langle F,D\rangle)\), send \((F,D,\sigma)\) 
  to server.
  \item Client keeps only \(vk\).
  \item Retrieval: server returns \((D',\sigma')\).
  \item Verify: accept if \(\text{Verify}(vk,\langle F,D'\rangle,\sigma') = 1\).
\end{itemize}

Difference from pure hashing:
\begin{itemize}
  \item Signatures are publicly verifiable (third parties can check).
  \item Useful for transferable proofs of origin and integrity.
\end{itemize}

\subsection{Merkle Trees}

\subsubsection{Structure}

Goal: authenticate large data split into blocks, and allow efficient verification of 
individual blocks.

\begin{itemize}
  \item Split data \(D\) into blocks \(D_1,\dots,D_n\).
  \item Compute leaf hashes \(H_1 = H(D_1),\dots,H_n = H(D_n)\).
  \item Build a binary tree:
    \[
      H_{i,j} = H(H_i \Vert H_j)
    \]
    up to a single \emph{Merkle root} \(MTR\).
\end{itemize}

Client stores only \(MTR\) as the commitment to the entire file.

\subsubsection{Merkle-based storage protocol}

\begin{itemize}
  \item Upload: client sends full \(D\) to server, builds Merkle tree locally and 
  computes root \(MTR\), then keeps only \(MTR\).
  \item Retrieval of a block \(D_x\): server returns \(D_x\) and 
  a \emph{proof of inclusion} \(\pi\).
  \item Verification: client uses \(D_x\), \(\pi\), and \(H\) to recompute 
  a root and checks that it equals stored \(MTR\).
\end{itemize}

\subsubsection{Proof of inclusion}

For a block \(D_x\):
\begin{itemize}
  \item Proof consists of all sibling hashes along the path from the leaf \(H(D_x)\) to the root.
  \item Verifier:
    \begin{enumerate}
      \item Starts from \(H(D_x)\).
      \item Iteratively combines with sibling hashes and hashes upward.
      \item Checks whether the final value equals \(MTR\).
    \end{enumerate}
\end{itemize}

Tree height is \(O(\log n)\) for \(n\) leaves, so proof size and verification time are \(O(\log n)\).

\subsubsection{Applications}

\begin{itemize}
  \item BitTorrent: verify file chunks during download.
  \item Bitcoin: Merkle tree of transactions inside each block.
  \item Ethereum: variants of Merkle trees for state and transactions.
\end{itemize}

\subsection{Merkle Trees for Sets}

Goal: store a set \(S\) on a server and later prove membership or non-membership of any element \(x\).

Construction:
\begin{itemize}
  \item Sort the elements of \(S\).
  \item Build a Merkle tree where leaves are sorted elements.
\end{itemize}

\subsubsection{Membership proof}

If \(x \in S\), the server provides a normal proof of inclusion for the leaf corresponding to \(x\).

\subsubsection{Non-membership proof}

If \(x \notin S\):
\begin{itemize}
  \item Find neighbors \(H_{<}\) and \(H_{>}\) in the sorted order such that \(H_{<} < x < H_{>}\).
  \item Provide inclusion proofs for \(H_{<}\) and \(H_{>}\).
  \item Show they are adjacent in the sorted set representation.
  \item Conclude that \(x\) is not present.
\end{itemize}

\subsection{Tries and Patricia Tries}

\subsubsection{Trie (prefix tree)}

Data structure for a set of key-value pairs \(\{(key,value)\}\) where keys are strings.

\begin{itemize}
  \item Each edge is labeled with a character.
  \item A path from the root spells out a key.
  \item Nodes may store values for keys ending at that node.
\end{itemize}

Operations:
\begin{itemize}
  \item \textbf{add(key,value)}: follow or create edges for each character, 
  then store the value at the final node.
  \item \textbf{query(key)}: follow edges by characters, and check whether 
  the final node has a value.
\end{itemize}

\subsubsection{Patricia Trie}

Compressed version of a Trie:
\begin{itemize}
  \item Any chain of nodes where each node has a single child and no value 
  can be merged into a single edge labeled with a substring.
  \item Saves space and reduces tree height.
\end{itemize}

Patricia tries are widely used in blockchain systems for efficient key-value storage.

\subsection{Merkle Patricia Trie (MPT)}

Ethereum combines Merkle hashing with Patricia tries.

\subsubsection{Node types}

Keys are encoded in hexadecimal nibbles. There are three logical node types:


\begin{itemize}
  \item \textbf{Leaf node}: stores remaining key fragment and the value.
  \item \textbf{Extension node}: stores a shared key prefix and a pointer to another node.
  \item \textbf{Branch node}: has up to 16 child pointers (for hex digits) plus an optional value.
\end{itemize}

Each logical node is serialized and hashed. Child pointers store the hash of the child node, 
so the root hash commits to the entire key-value map.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_merkle_paricia_trie.png}
\end{figure}


\subsubsection{Properties}

\begin{itemize}
  \item Root hash acts as a commitment to the whole dictionary.
  \item Inclusion proofs: show the path from the root down to a leaf and the content of 
  intermediate nodes.
  \item Non-inclusion proofs: show that the search path terminates at a node that proves 
  no matching key exists.
  \item Ethereum uses an MPT for the global world state, and the state root hash is stored 
  in the block header.
\end{itemize}

\subsection{Blockchain Data Structures}

\subsubsection{Block structure}

A block consists of:
\begin{itemize}
  \item Random nonce \(\text{ctr}\).
  \item Data \(x\) (e.g. transactions, root hashes).
  \item Pointer \(s\) to the previous block (usually a hash of the previous header).
\end{itemize}

The header typically includes \((\text{ctr}, x, s)\). The pointer field \(s\) creates a hash 
chain of blocks back to the genesis block.

\subsubsection{Proof of Work (PoW)}

In PoW systems a block header must satisfy:
\[
  H(\text{ctr} \Vert x \Vert s) \le T
\]
where \(T\) is a global difficulty target.

\begin{itemize}
  \item Miners fix \(x\) and \(s\), iterate over \(\text{ctr}\), and search for a header whose 
  hash is below \(T\).
  \item The same hash is also used as the block identifier.
\end{itemize}

\subsection{Bitcoin Overview}

\subsubsection{High-level protocol}

\begin{enumerate}
  \item New transactions are broadcast to the network.
  \item Nodes collect transactions into candidate blocks.
  \item Nodes perform PoW to find valid blocks.
  \item A node that finds a valid block broadcasts it.
  \item Other nodes validate all transactions and the PoW before accepting.
  \item Nodes start mining on top of the longest valid chain.
\end{enumerate}

\subsubsection{UTXO model}

Bitcoin represents ownership via unspent transaction outputs (UTXOs).

\begin{itemize}
  \item A transaction has multiple inputs and outputs.
  \item Each \textbf{input} references a previous output (by transaction hash and index) and 
  provides a script that authorizes spending.
  \item Each \textbf{output} specifies a value and a script defining how it may be spent in the future.
\end{itemize}

\subsubsection{Scripts}

Typical pay-to-public-key-hash (P2PKH) transaction:

\begin{itemize}
  \item Output script (\texttt{scriptPubKey}): 
  \begin{align*}
    \text{OP\_DUP}\ \text{OP\_HASH160}\ \langle \text{pubKeyHash} \rangle \\
    \text{OP\_EQUALVERIFY}\ \text{OP\_CHECKSIG}
  \end{align*}
  
  \item Input script (\texttt{scriptSig}) when spent: 
  \[
    \langle sig \rangle\ \langle pubKey \rangle
  \]
\end{itemize}

During validation, the combined script is executed to check that the spender owns the 
corresponding private key.

\subsubsection{Merkle tree of transactions in a block}

\begin{itemize}
  \item All transactions in a block are organized as a Merkle tree.
  \item The Merkle root is stored in the block header.
  \item Simplified payment verification (SPV) clients download only block headers and 
  proofs of inclusion for specific transactions.
\end{itemize}

\subsection{Bitcoin Network}

\subsubsection{P2P topology}

\begin{itemize}
  \item All nodes run the same open-source protocol.
  \item Each node maintains connections to a set of peers.
  \item The network is permissionless: nodes may join or leave at any time.
\end{itemize}

Bootstrapping:
\begin{itemize}
  \item Peer-to-peer nodes come “pre-installed” with some peers by IP / host.
  \item A user can also manually configure known peers.
\end{itemize}

\subsubsection{Gossip protocol}

\begin{itemize}
  \item When a node learns about a new transaction or block, it forwards it to its peers.
  \item Each peer that sees a new item forwards it to its own peers.
  \item Nodes ignore items they have already seen.
  \item This peer-to-peer diffusion eventually spreads data to most honest nodes.
\end{itemize}

\subsubsection{Eclipse attacks and connectivity assumption}

\textbf{Connectivity assumption}: every honest node can reach every other honest node 
through some path in the network.

\textbf{Eclipse attack}:
\begin{itemize}
  \item Attacker surrounds a victim with malicious peers.
  \item Victim only connects to attacker-controlled nodes and is cut off from the honest network.
  \item This can delay or hide blocks and transactions, enabling double spending or 
  inconsistent views.
\end{itemize}

Maintaining good connectivity and diverse peer sets is critical for blockchain security.

\subsection{Quick Summary}

\begin{itemize}
  \item Hashes and signatures support basic authenticated storage.
  \item Merkle trees give efficient proofs of inclusion with size \(O(\log n)\).
  \item Merkle trees extend to sets and enable non-membership proofs.
  \item Tries store key-value maps by sharing prefixes; Patricia tries compress long paths.
  \item Merkle Patricia tries combine hashing and compressed tries; Ethereum uses them for state.
  \item Blockchain data structures link blocks using hash pointers and PoW.
  \item Bitcoin uses UTXOs, scripts, Merkle trees of transactions, and a P2P gossip network.
\end{itemize}

\section{Week 3}

\subsection{Smart Contracts: Concept}

\textbf{Smart contract:} a computer program that runs on the blockchain.

\begin{itemize}
  \item Code is stored on chain and executed by all full nodes.
  \item Execution is deterministic: all honest nodes get the same outcome.
  \item Code can read:
  \begin{itemize}
    \item Its own internal storage.
    \item Transaction context (sender, value, data).
    \item Recent block data (in Ethereum).
  \end{itemize}
  \item Code of a deployed contract cannot change (immutability).
\end{itemize}

Legal caution: from a legal point of view, ``smart contracts'' are usually neither legally smart nor contracts; they are programs enforcing some rules on chain.

\subsection{Bitcoin Transactions and Script}

\subsubsection{Transaction structure}

A Bitcoin transaction consists of:

\begin{itemize}
  \item \textbf{Inputs}:
  \begin{itemize}
    \item Reference to a previous transaction output (tx hash + index).
    \item \texttt{scriptSig}: unlocking script that proves right to spend.
  \end{itemize}
  \item \textbf{Outputs}:
  \begin{itemize}
    \item \texttt{value}: amount of BTC.
    \item \texttt{scriptPubKey}: locking script specifying spending conditions.
  \end{itemize}
\end{itemize}

Validation rule: for each input, the node executes
\[
\texttt{scriptSig} \Vert \texttt{scriptPubKey}
\]
on a stack machine and checks that it finishes with value \texttt{TRUE} on top of the stack.

\subsubsection{Bitcoin Script basics}

\begin{itemize}
  \item Stack based, not Turing complete.
  \item Data (e.g. \texttt{<sig>}, \texttt{<pubKey>}) is pushed to the stack.
  \item \textbf{Opcodes}:
  \begin{itemize}
    \item Arithmetic: \texttt{OP\_ADD}, \texttt{OP\_ABS}, \dots
    \item Stack operations: \texttt{OP\_DROP}, \texttt{OP\_SWAP}.
    \item Comparisons: \texttt{OP\_EQUAL}, \texttt{OP\_EQUALVERIFY}.
    \item Crypto: \texttt{OP\_HASH160}, \texttt{OP\_SHA256}.
    \item Signatures: \texttt{OP\_CHECKSIG}, \texttt{OP\_CHECKMULTISIG}.
    \item Timelocks: \texttt{OP\_CHECKLOCKTIMEVERIFY}, \texttt{OP\_CHECKSEQUENCEVERIFY}.
  \end{itemize}
\end{itemize}

\subsubsection{P2PKH example}

\textbf{Output script (\texttt{scriptPubKey}):}
\[
\texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
\]

\textbf{Input script (\texttt{scriptSig}) when spending:}
\[
\texttt{<sig> <pubKey>}
\]

Execution steps:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/btc_script_example.png}
\end{figure}

\subsection{Limitations of Bitcoin Script}

\begin{itemize}
  \item \textbf{No loops} and restricted control flow: not Turing complete.
  \item \textbf{No internal state}: script cannot store persistent variables.
  \item \textbf{Value blind}: script cannot inspect the exact amount being sent, it just validates spending conditions.
  \item \textbf{Blockchain blind}: cannot access block header fields (e.g. nonce, previous hash) except for basic locktime operations.
\end{itemize}

These limitations make Bitcoin simple and secure but restrict expressiveness.

\subsection{Extending Bitcoin Functionality}

Two main options:

\subsubsection{Build on top of Bitcoin}

\begin{itemize}
  \item Use Bitcoin as a base layer and encode extra logic at a higher protocol layer.
  \item Pros: reuses existing security and mining power; cheaper to deploy.
  \item Cons: limited flexibility because higher layer must respect Bitcoin's script and transaction model.
\end{itemize}

\subsubsection{Build an independent blockchain}

\begin{itemize}
  \item Design a new protocol from scratch (e.g. Ethereum).
  \item Pros: can add new opcodes and richer state; more expressive smart contracts.
  \item Cons: must bootstrap own validators or miners; higher development and maintenance cost.
\end{itemize}

\subsection{Ethereum Overview}

Ethereum keeps the blockchain idea but turns it into a \textbf{universal replicated state machine}.

\begin{itemize}
  \item One global state shared by all nodes.
  \item Transactions are state transition requests.
  \item A virtual machine (EVM) applies transactions to the state.
  \item Turing complete bytecode language for smart contracts.
  \item Decentralized applications (DApps) can be deployed and executed on chain.
\end{itemize}

Consensus and Sybil resistance:

\begin{itemize}
  \item Originally Proof of Work (Ethash), now Proof of Stake (validators, staking, Gasper).
\end{itemize}

\subsection{Ethereum Accounts}

\subsubsection{Global state}

Ethereum's global state is a mapping from 20-byte addresses to account objects.

Each account has:

\begin{itemize}
  \item \texttt{address}: 160-bit identifier.
  \item \texttt{balance}: amount of Ether (in wei).
  \item \texttt{nonce}: number of sent transactions.
  \item (for contract accounts) \texttt{code} and \texttt{storage}.
\end{itemize}

\subsubsection{Two types of accounts}

\textbf{Externally Owned Account (EOA):}

\begin{itemize}
  \item Address is derived from a public key: \(\text{addr} = H(\text{pubKey})\).
  \item Controlled by a private key held by a user.
  \item No code or storage.
\end{itemize}

\textbf{Contract account:}

\begin{itemize}
  \item Address is derived from creator address and nonce.
  \item Contains immutable contract code and persistent storage.
  \item Cannot initiate transactions on its own; reacts to incoming transactions or messages.
\end{itemize}

\subsubsection{UTxO vs account model}

\begin{itemize}
  \item UTxO:
  \begin{itemize}
    \item Better for privacy and parallelism.
    \item Outputs are spent or unspent.
  \end{itemize}
  \item Account model (Ethereum):
  \begin{itemize}
    \item Conceptually simpler.
    \item More compact representation of balances and state.
  \end{itemize}
\end{itemize}

\subsection{Ethereum Transactions}

A transaction includes:

\begin{itemize}
  \item \texttt{from}: recovered from the signature (sender's address).
  \item \texttt{to}: recipient address (EOA or contract). If empty, this is a contract creation tx.
  \item \texttt{value}: amount of Ether in wei.
  \item \texttt{data}: payload. For contracts this encodes which function to call and its arguments. Empty for simple ETH transfers.
  \item \texttt{nonce}: counts how many transactions the sender has already sent, prevents replay.
  \item \texttt{gasLimit} (\texttt{startgas}): maximum gas units the sender is willing to use.
  \item \texttt{gasPrice}: price per gas unit (or fee parameters in newer fee model).
  \item \texttt{signature}: proves authorization by the sender.
\end{itemize}

\subsubsection{Types of transactions}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_tx_types.png}
\end{figure}

\subsection{Ethereum Block Structure and Production}

\subsubsection{Block header format}

Each Ethereum block contains the list of transactions and a commitment to the most recent global state.

The block header stores:

\begin{itemize}
  \item \textbf{prev}: hash pointer to the previous block.
  \item \textbf{hash}: block hash (identifier).
  \item \textbf{time}: block timestamp.
  \item \textbf{gasLimit}: maximum total gas allowed in the block.
  \item \textbf{gasUsed}: total gas consumed by included transactions.
  \item \textbf{nonce}: used in the old PoW design (no longer relevant under PoS).
  \item \textbf{difficulty}: PoW difficulty (historical field).
  \item \textbf{miner}: address of the block proposer (validator under PoS).
  \item \textbf{extra}: optional metadata.
  \item \textbf{state root}: Merkle Patricia Trie root of the global account state.
  \item \textbf{transaction root}: Merkle root of all transactions in this block.
  \item \textbf{receipt root}: Merkle root of all transaction receipts (status, logs, gas usage).
\end{itemize}

The \textbf{state root} commits to all accounts, where each account record contains:
\begin{itemize}
  \item \textbf{address}
  \item \textbf{code} (empty for EOAs)
  \item \textbf{storage} (persistent key/value data)
  \item \textbf{balance} (in wei)
  \item \textbf{nonce} (number of sent transactions)
\end{itemize}

\subsubsection{Block production and rewards}

\begin{itemize}
  \item Blocks contain: the ordered transaction list and the most recent state (via the state root).
  \item Typical block time: about \textbf{12 seconds}.
  \item Since 2022, Ethereum uses \textbf{Proof-of-Stake (Gasper)} for Sybil resistance and consensus.
  \item Previously, Ethereum used \textbf{Proof-of-Work} with Ethash (memory-hard PoW).
\end{itemize}

Rewards and fees:

\begin{itemize}
  \item \textbf{Before the Merge (PoW):} block miner received a fixed block reward (e.g.\ 2 ETH) plus all transaction fees.
  \item \textbf{After the Merge (PoS):}
  \begin{itemize}
    \item The block proposer (validator) receives a \textbf{base block reward} (newly issued ETH), depending on total ETH staked.
    \item Each transaction has a \textbf{base fee} which is \emph{burned}, reducing total ETH supply.
    \item Users can add \textbf{priority fees (tips)} that are paid directly to the block proposer.
  \end{itemize}
\end{itemize}


\subsection{Messages between contracts}

Contracts cannot create real transactions, but can send \emph{messages}:

\begin{itemize}
  \item Messages are internal calls generated by running contract code.
  \item They exist only inside EVM execution and are not part of the P2P network.
  \item A message can transfer ETH and call functions of other contracts.
\end{itemize}

Execution chain:

\begin{itemize}
  \item External transaction triggers code of a contract.
  \item That contract can send messages to other contracts.
  \item Each recipient runs its code in turn.
\end{itemize}

\subsection{Ethereum Virtual Machine (EVM)}

\begin{itemize}
  \item Stack based architecture with 1024-element stack of 256-bit words.
  \item Bytecode instruction set; each opcode has a defined gas cost.
  \item Three data areas:
  \begin{itemize}
    \item \textbf{Stack}: last-in first-out, used for intermediate values.
    \item \textbf{Memory}: transient byte array, cleared between transactions.
    \item \textbf{Storage}: persistent key-value store, written to and read by contract code.
  \end{itemize}
  \item Crypto primitives: hash functions, signature verification.
  \item Can read execution context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{block.timestamp}, etc.
\end{itemize}

\subsection{Gas and Transaction Fees}

\subsubsection{Why gas is needed}

\begin{itemize}
  \item Every node must execute all transactions and keep the full state.
  \item Without limits, a malicious contract could run forever (halting problem).
  \item Gas sets a hard bound on how much computation and storage a transaction may consume.
\end{itemize}

\subsubsection{Gas fields in a transaction}

\begin{itemize}
  \item \textbf{Gas limit} (\texttt{startgas}): maximum gas units the sender allows for this transaction.
  \item \textbf{Gas price}: price per gas unit in wei (or equivalent fee parameters).
\end{itemize}

Maximum fee the sender is willing to pay is:
\[
\text{maxFee} = \text{gasLimit} \times \text{gasPrice}.
\]

\subsubsection{Execution with gas}

Simplified algorithm for a transaction:

\begin{enumerate}
  \item Check that \(\text{gasLimit} \times \text{gasPrice} \le \text{balance}\). If not, reject.
  \item Deduct \(\text{gasLimit} \times \text{gasPrice}\) from sender balance.
  \item Set \texttt{gas} \(\leftarrow \text{gasLimit}\).
  \item Execute bytecode, decreasing \texttt{gas} by the cost of each operation.
  \item If execution finishes normally, refund unused gas:
  \[
  \text{refund} = \text{gasRemaining} \times \text{gasPrice}.
  \]
  \item If gas reaches zero before finishing (out of gas), revert state changes. The prepaid fee is not refunded.
\end{enumerate}

Note: blocks also have a \emph{block gas limit}, so the sum of gas used by all transactions in a block cannot exceed this bound.

\subsection{Introduction to Solidity}

Solidity is a high level language that compiles to EVM bytecode.

\begin{itemize}
  \item Syntax resembles JavaScript.
  \item Statically typed: every variable must have an explicit type.
  \item Supports contracts, state variables, functions, events, modifiers, inheritance, and interfaces.
\end{itemize}

\subsubsection{Basic contract example}

A minimal contract usually:

\begin{itemize}
  \item Starts with a \texttt{pragma} line specifying the compiler version range.
  \item Declares a \texttt{contract} with a name.
  \item Contains one or more functions. For example, a simple contract \texttt{HelloWorld} may have a \texttt{print} function marked \texttt{public} and \texttt{pure} that returns the string \texttt{"Hello World!"}.
\end{itemize}

\subsection{Solidity: Variables and Types}

\subsubsection{State vs local variables}

\begin{itemize}
  \item \textbf{State variables}:
  \begin{itemize}
    \item Declared at contract level.
    \item Stored in contract storage (persistent and expensive to change).
  \end{itemize}
  \item \textbf{Local variables}:
  \begin{itemize}
    \item Declared inside functions.
    \item Live only during function execution.
    \item Value types are kept on the stack; reference types require an explicit data location.
  \end{itemize}
\end{itemize}

\subsubsection{Value types}

\begin{itemize}
  \item \textbf{bool}: \texttt{true} or \texttt{false}.
  \item \textbf{int} and \textbf{uint}: signed and unsigned integers of 8 to 256 bits (e.g.\ \texttt{uint256}, \texttt{int8}).
  \item \textbf{address}: 20-byte address; \texttt{address payable} can receive Ether.
  \item \textbf{bytes1} to \textbf{bytes32}: fixed size byte arrays.
  \item \textbf{enum}: user defined type with a finite set of named values.
\end{itemize}

Variables without explicit initialization receive the default zero value for their type.

\subsubsection{Reference types}

\begin{itemize}
  \item Dynamic arrays: \texttt{uint[]} or \texttt{bytes} or \texttt{string}.
  \item Static arrays: for example, \texttt{uint[5]}.
  \item \textbf{mapping(KeyType => ValueType)}: key-value dictionary, non-iterable.
  \item \textbf{struct}: groups multiple fields into one type, e.g.\ a \texttt{Voter} struct with fields for weight, address, and whether they have voted.
\end{itemize}

\subsection{Visibility and Function Types}

\subsubsection{Visibility of functions and variables}

\begin{itemize}
  \item \textbf{public}:
  \begin{itemize}
    \item Functions callable from outside and inside contracts.
    \item For public state variables, the compiler generates a getter automatically.
  \end{itemize}
  \item \textbf{external}:
  \begin{itemize}
    \item Callable only from outside the contract.
    \item Cannot be used for state variables.
  \end{itemize}
  \item \textbf{internal}:
  \begin{itemize}
    \item Callable only inside the contract or from derived contracts.
  \end{itemize}
  \item \textbf{private}:
  \begin{itemize}
    \item Callable only inside the contract that defines them (not visible in children).
  \end{itemize}
\end{itemize}

\subsubsection{Function modifiers (state mutability)}

\begin{itemize}
  \item \textbf{view}: function promises not to modify state, but may read it.
  \item \textbf{pure}: function promises not to read or modify state (depends only on its arguments).
  \item \textbf{payable}: function can receive Ether along with the call.
\end{itemize}

Remember: on-chain data is publicly visible regardless of visibility keywords; these only restrict who can \emph{invoke} a function.

\subsection{Solidity Inheritance and Interfaces}

\begin{itemize}
  \item Solidity supports multiple inheritance between contracts.
  \item The keyword \texttt{is} is used to derive one contract from another.
  \item Derived contracts can access non-\texttt{private} state and internal functions of parents.
  \item Interfaces are abstract contracts that only declare function signatures (no implementation). Implementing contracts must provide the body of each function.
\end{itemize}

Typical pattern:

\begin{itemize}
  \item Define an interface \texttt{Regulator} that specifies functions like \texttt{checkValue} and \texttt{loan}.
  \item Implement a concrete \texttt{Bank} contract \texttt{is Regulator} that maintains an internal balance, implements deposit/withdraw functions, and provides concrete definitions of \texttt{checkValue} and \texttt{loan}.
\end{itemize}

\subsection{Data Location: storage, memory, calldata}

\begin{itemize}
  \item \textbf{storage}:
  \begin{itemize}
    \item Persistent key-value store for state variables.
    \item Expensive to read and write; changes are stored on chain.
  \end{itemize}
  \item \textbf{memory}:
  \begin{itemize}
    \item Temporary area for reference types inside functions.
    \item Cleared after the function ends.
  \end{itemize}
  \item \textbf{calldata}:
  \begin{itemize}
    \item Read-only location for function arguments of external functions.
    \item Cheaper than memory for dynamic types.
  \end{itemize}
\end{itemize}

Assignment behaviour:

\begin{itemize}
  \item \texttt{storage} $\leftrightarrow$ \texttt{memory}: data is copied.
  \item \texttt{memory} $\leftrightarrow$ \texttt{memory}: references are passed.
  \item Local variables of type \texttt{storage} act as references (aliases) to existing state variables.
\end{itemize}

\subsection{Events and Modifiers}

\subsubsection{Events}

\begin{itemize}
  \item Provide a logging mechanism inside the EVM.
  \item Event arguments are stored in the transaction log, not in contract storage.
  \item Off-chain clients (e.g.\ in JavaScript or Python) can subscribe to events and react to them.
  \item A typical pattern is an event such as \texttt{Deposit(from, id, value)} emitted whenever Ether is deposited into the contract.
\end{itemize}

\subsubsection{Modifiers}

\begin{itemize}
  \item Modifiers are reusable preconditions or wrappers around functions.
  \item The body of the modifier is injected at the point where \texttt{\_;} appears.
  \item Common example: an \texttt{onlyOwner} modifier that checks \texttt{msg.sender == owner} before executing the function body.
  \item A contract \texttt{Owned} may set the \texttt{owner} to the deployer in the constructor and define \texttt{onlyOwner}; a derived contract \texttt{Mortal} can then protect a \texttt{close} function with this modifier.
\end{itemize}

\subsection{Global Variables and Units}

\subsubsection{Ether units}

\begin{itemize}
  \item \texttt{1 ether == 10\string^18 wei}.
  \item Other common units: \texttt{wei}, \texttt{gwei}, \texttt{szabo}, \texttt{finney}.
\end{itemize}

\subsubsection{Time units}

\begin{itemize}
  \item Suffixes: \texttt{seconds}, \texttt{minutes}, \texttt{hours}, \texttt{days}, \texttt{weeks}.
  \item Example: \texttt{1 hours == 60 minutes}.
\end{itemize}

\subsubsection{Common global variables}

\begin{itemize}
  \item Block properties: \texttt{block.timestamp}, \texttt{block.number}, \texttt{block.coinbase}.
  \item Transaction and message context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{msg.data}, \texttt{tx.origin}.
  \item Address helpers: \texttt{addr.balance}, \texttt{addr.transfer(...)}, \texttt{addr.call(...)}.
\end{itemize}

\subsection{Fallback and Receive Functions}

\begin{itemize}
  \item \texttt{receive()}:
  \begin{itemize}
    \item Declared as \texttt{receive() external payable}.
    \item Executed when the contract receives Ether with empty data.
  \end{itemize}
  \item \texttt{fallback()}:
  \begin{itemize}
    \item Declared as \texttt{fallback() external} (optionally \texttt{payable}).
    \item Executed when no other function matches the call data, or when data is non-empty and \texttt{receive} does not exist.
  \end{itemize}
  \item Both functions should be simple and use little gas to avoid unexpected failures.
\end{itemize}

\subsection{Sending Ether: transfer, send, call}

\begin{itemize}
  \item \texttt{transfer}:
  \begin{itemize}
    \item Forwards 2300 gas to the recipient.
    \item Reverts on failure.
    \item Historically considered safe against re-entrancy because the gas stipend is small.
  \end{itemize}
  \item \texttt{send}:
  \begin{itemize}
    \item Also forwards 2300 gas.
    \item Returns a boolean success flag instead of reverting; caller must check it.
  \end{itemize}
  \item Low-level \texttt{call} with value:
  \begin{itemize}
    \item Can send Ether and forward an arbitrary amount of gas.
    \item Returns a success flag and returned data.
    \item Flexible but vulnerable to re-entrancy if state updates and external calls are not ordered carefully.
  \end{itemize}
\end{itemize}

Best practice: use \texttt{call} together with the checks--effects--interactions pattern and, if needed, explicit re-entrancy guards.

\subsection{Interacting with Other Contracts}

\begin{itemize}
  \item Contracts can create new contracts and call existing ones.
  \item A typical pattern: a ``factory'' contract that deploys new instances of another contract (e.g.\ \texttt{Universe} creating many \texttt{Planet} contracts), stores their addresses in an array, and emits an event each time a new instance is created.
  \item Interaction is done by using the other contract's type and calling its functions as methods.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Bitcoin uses a stack based, non Turing complete scripting system to authorise spending of UTxOs.
  \item Ethereum generalises blockchains into a universal replicated state machine with accounts, contracts, and global state.
  \item The EVM is a stack machine with storage, memory, and stack; gas ensures that computation is bounded and paid for.
  \item Solidity is a high level language for writing contracts, with explicit types, visibility, data locations, and support for inheritance.
  \item Events, modifiers, and global variables are key tools for building practical contracts.
  \item Ether transfers use \texttt{transfer}, \texttt{send}, or \texttt{call}; understanding their differences is important for security.
\end{itemize}


\section{Week 4}

\subsection{1. Lecture Overview}
This lecture focuses on identifying security hazards in smart contracts and designing safer contract architectures. We examine four main attack vectors:
\begin{itemize}
    \item Denial-of-Service (DoS)
    \item Griefing attacks
    \item Reentrancy attacks
    \item Front-running
\end{itemize}

Key defensive patterns include Pull-over-Push, Checks--Effects--Interactions, safe fallback design, avoiding \texttt{tx.origin}, safe randomness, and overflow/underflow protection.

\subsection{2. Denial-of-Service and Griefing}

\textbf{Unbounded loops} can make functions impossible to execute once arrays grow large.
Example insecure pattern:
\begin{verbatim}
for (uint i=0; i<investors.length; i++) {
    investors[i].addr.send(investors[i].dividendAmount);
}
\end{verbatim}

As the array size increases, gas requirements exceed block limits, leading to DoS.  
Griefing attacks intentionally exploit this by causing certain \texttt{send()} calls to fail, blocking all refunds.

\textbf{Solution: Pull-over-Push}.  
Instead of transferring funds inside a loop, store refund balances and allow users to withdraw individually.
\begin{verbatim}
// Pull model
refunds[user] += amount;
function withdrawRefund() external {
    uint r = refunds[msg.sender];
    refunds[msg.sender] = 0;
    msg.sender.transfer(r);
}
\end{verbatim}

\subsection{3. Reentrancy Attacks}

A reentrancy attack occurs when an external call triggers a fallback function that re-enters the vulnerable contract before state updates occur.

\textbf{Vulnerable pattern:}
\begin{verbatim}
uint amount = balances[msg.sender];
require(msg.sender.call.value(amount)());
balances[msg.sender] = 0;
\end{verbatim}

Attackers repeatedly drain funds through recursive fallback calls.  
The DAO attack (2016) exploited this weakness, resulting in a \$50M loss.

\textbf{Mitigation: Checks--Effects--Interactions.}
\begin{verbatim}
uint amount = balances[msg.sender];
balances[msg.sender] = 0;
msg.sender.transfer(amount);
\end{verbatim}

Additional protections: mutex locks, Pull-over-Push pattern.

\subsection{4. Solidity-Specific Hazards}

\textbf{4.1 Forcibly sending Ether}.  
Ether can be sent to a contract without triggering fallback functions, e.g.:
\begin{itemize}
    \item \texttt{selfdestruct(target)}
    \item precomputed contract addresses
    \item block reward redirection
\end{itemize}
Thus, do not rely on strict balance equality.

\textbf{4.2 Delegatecall hazards}.  
\texttt{delegatecall} uses the caller's storage and \texttt{msg.sender}.  
Malicious libraries can overwrite critical variables like \texttt{owner}.

\textbf{4.3 Misuse of \texttt{tx.origin}}.  
Using \texttt{tx.origin} for authorization enables phishing attacks. Always use \texttt{msg.sender}.

\textbf{4.4 Fallback complexity}.  
Fallback functions should contain minimal logic to avoid vulnerabilities such as reentrancy.

\textbf{4.5 Default values}.  
Uninitialized mapping entries return default values (e.g., 0).  
Incorrect handling led to the Nomad Bridge hack (2022).

\subsection{5. Merkle Tree Vulnerabilities}

Sparse Merkle Trees assign empty values to uninitialized leaves, enabling forged proofs.  
Binance Bridge was exploited through a manipulated AVL Merkle proof.  
Avoid custom cryptographic implementations unless formally verified.

\subsection{6. Front-running Attacks}

Miners reorder transactions by gas price.  

Example:
\begin{verbatim}
registerName("alice")
\end{verbatim}
An attacker sends:
\begin{verbatim}
registerName("alice") // higher gas price
\end{verbatim}

\textbf{Commit--Reveal Scheme} prevents this:
\begin{itemize}
    \item Commit: \texttt{hash(value, nonce)}
    \item Reveal later
    \item Verify hash
\end{itemize}

\subsection{7. Randomness Hazards}

Sources like \texttt{block.timestamp}, \texttt{block.number}, \texttt{blockhash}, \texttt{msg.sender} are predictable or miner-controlled.

Future blockhash is also insecure because miners can withhold or reorder blocks.

\textbf{Secure randomness: Commit--Reveal}.  
Both parties commit to random values, reveal later, then combine (e.g., XOR).  
If either party is honest, randomness is secure.

\subsection{8. Integer Overflow and Underflow}

Prior to Solidity~0.8, arithmetic did not include overflow checks.  
Example:
\begin{verbatim}
balance[msg.sender] -= value;
\end{verbatim}

Mitigation:
\begin{itemize}
    \item Use Solidity 0.8+ (automatic checks)
    \item Use SafeMath for older versions
\end{itemize}

\subsection{9. Gas Fairness}

Depending on contract design:
\begin{itemize}
    \item Last contributor may pay all gas
    \item Beneficiary may pay
    \item All parties may share costs
\end{itemize}

Fairness must be considered in crowdfunding or payout logic.

\subsection{10. Example of an Insecure Contract}

The Rock--Paper--Scissors example demonstrates:
\begin{itemize}
    \item Commit has no nonce, so the commitment \texttt{sha256(hand)} can be brute-forced (only 3 possibilities), letting an attacker discover the opponent's move before choosing their own.
    \item Anyone can call \texttt{open()}, meaning any account can reveal moves for players or manipulate when the game resolves.
    \item No deposit validation, so players can join without paying, and the contract incorrectly assumes it always holds exactly 1 ETH to pay the winner.
    \item \texttt{selfdestruct} sends all funds to the caller, allowing any user who triggers \texttt{open()} to steal the entire contract balance.
\end{itemize}


\section{Week 5}

\subsection{The Byzantine Generals Problem}

The Byzantine Generals Problem describes the difficulty of reaching agreement in a distributed system where some participants may behave arbitrarily or maliciously.

Key ideas:
\begin{itemize}
    \item Nodes may send conflicting or incorrect information.
    \item Honest parties cannot tell which messages are trustworthy.
    \item Reliable agreement requires a protocol that tolerates Byzantine faults.
\end{itemize}

This motivates the study of consensus protocols in adversarial environments.

\subsection{The Consensus Problem}

Consensus formalizes what it means for multiple parties to ``agree'' in a distributed setting.

A protocol must satisfy three properties:

\begin{itemize}
    \item \textbf{Termination}: every honest party eventually outputs a value.
    \item \textbf{Agreement}: all honest parties output the same value.
    \item \textbf{Validity}: if all honest parties start with the same input $v$, the output must be $v$.
\end{itemize}

\textbf{Strong validity} ensures that the output must originate from an honest party's input.

\subsection{Honest Majority Requirement}

There are fundamental impossibility results:

\begin{itemize}
    \item An adversary controlling too many parties can force violations of agreement or validity.
    \item In systems without trusted setup, consensus requires $t < n/3$ Byzantine faults.
    \item With cryptographic setup (e.g., PKI), consensus under synchrony is possible with $t < n/2$.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/consensus.png}
\end{figure}

Intuition: honest parties cannot distinguish among scenarios where different subsets of participants are corrupted; thus, too many adversarial parties break correctness.

\subsection{Classical vs Ledger Consensus}

Traditional consensus:
\begin{itemize}
    \item ``One-shot'' -- decides a single value.
    \item Uses authenticated channels and fixed participants.
    \item Ensures termination, agreement, validity.
\end{itemize}

Ledger (blockchain) consensus:
\begin{itemize}
    \item Runs indefinitely.
    \item Must incorporate new transactions continuously.
    \item Must tolerate dynamic participation and an unauthenticated, peer-to-peer network.
\end{itemize}

Ledger consensus replaces classical conditions with:
\begin{itemize}
    \item \textbf{Common Prefix} (consistency)
    \item \textbf{Chain Growth} (liveness)
    \item \textbf{Chain Quality} (adversarial influence bounded)
\end{itemize}

These properties define when a blockchain behaves like a consistent, append-only log.

\subsection{The Bitcoin Backbone Model}

Bitcoin is modeled as a protocol executed in synchronous rounds by many parties.

Core components:
\begin{itemize}
    \item \textbf{Chain validation predicate}: checks PoW correctness and structural validity.
    \item \textbf{Chain selection rule}: adopt the valid chain with the most cumulative work (``max-valid'' or longest chain rule).
    \item \textbf{Proof of Work function}: probabilistic mechanism enabling random leader election.
\end{itemize}

A block contains:
\begin{itemize}
    \item $\text{ctr}$: nonce for PoW.
    \item $x$: data such as transaction roots.
    \item $s$: hash pointer to previous block.
\end{itemize}

Finding a valid block requires hashing until:
\[
H(\text{ctr} \Vert x \Vert s) < T
\]
where $T$ is the global difficulty target.

\subsection{Key Security Properties of Blockchains}

\subsubsection{Common Prefix (Consistency)}

Honest parties’ blockchains differ only in the most recent $k$ blocks.  
This ensures finalized blocks do not get reverted.

Attack example:
\begin{itemize}
    \item \textbf{Racing attack}: adversary tries to build a secret chain to overtake the honest chain.
\end{itemize}

\subsubsection{Chain Growth}

In any sufficiently long period, the honest chain grows by at least a linear number of blocks.

Attack example:
\begin{itemize}
    \item \textbf{Abstention attack}: adversary withholds blocks to slow the chain.
\end{itemize}

\subsubsection{Chain Quality}

In any window of blocks, the fraction of adversarial blocks is bounded.  
This prevents adversaries from dominating the chain even if they temporarily get lucky.

Attack example:
\begin{itemize}
    \item \textbf{Block withholding attack}: adversary tries to replace honest blocks whenever they find their own.
\end{itemize}

\subsection{From Blockchain Properties to Ledger Consensus}

\begin{itemize}
    \item \textbf{Consistency} of the ledger derives from the Common Prefix property.
    \item \textbf{Liveness} derives from the combination of Chain Growth and Chain Quality.
    \item Honest blocks eventually appear and become irreversible after $k$ confirmations.
\end{itemize}

Thus, the blockchain implements a robust form of asynchronous, permissionless consensus.

\subsection{Proof of Work and Mining}

PoW mining is essentially a randomized leader election mechanism.

Properties:
\begin{itemize}
    \item Parallelizable: miners increase success probability by adding more hash power.
    \item Easy verification: given the nonce, checking PoW is one hash computation.
    \item Hard to shortcut: success probability is proportional to computational power.
\end{itemize}

\subsection{Mining Pools}

Because PoW rewards are probabilistic, miners cooperate in pools:

\begin{itemize}
    \item Miners submit ``shares'' to prove contributed work.
    \item Pool distributes rewards proportionally to contributed hash power.
\end{itemize}

\subsection{Dynamic Availability and Difficulty Adjustment}

Bitcoin must operate despite fluctuating numbers of miners.

\begin{itemize}
    \item If total hash power increases, blocks appear too quickly.
    \item If hash power decreases, block production slows.
\end{itemize}

Bitcoin adjusts difficulty every 2016 blocks to keep block intervals stable.

Let $f$ be the probability that at least one honest miner finds a block in a round:
\begin{itemize}
    \item If $f$ is too small: chain grows too slowly → liveness suffers.
    \item If $f$ is too large: many forks occur → consistency suffers.
\end{itemize}

Difficulty adjustment keeps $f$ within a safe range.

\subsection{Difficulty Raising Attack}

If the difficulty adjustment mechanism were poorly designed, an adversary with minority hash power could:
\begin{itemize}
    \item create a private chain with artificially high difficulty,
    \item exploit increased variance to occasionally overtake the honest chain.
\end{itemize}

Bitcoin avoids this by bounding difficulty adjustment using the epoch threshold.

\subsection{Summary}

\begin{itemize}
    \item Consensus in adversarial networks requires dealing with Byzantine faults.
    \item Classical consensus properties map to blockchain properties: Common Prefix, Chain Growth, Chain Quality.
    \item Bitcoin's PoW, longest chain rule, and difficulty adjustment together implement a secure ledger.
    \item Attacks such as racing, withholding, and difficulty raising highlight why the assumptions and parameter choices matter.
\end{itemize}

\section{Week 6}

\subsection*{Permissionless Protocols and Dynamic Availability}

Many blockchain protocols, such as Bitcoin, operate in a \textbf{permissionless} setting:

\begin{itemize}
  \item Anyone can join or leave the network without prior authorization.
  \item Anyone can read the ledger and, after acquiring coins, submit transactions.
  \item Participation in block production is open to anyone with the relevant resource (e.g.\ hash power).
\end{itemize}

The system must tolerate \textbf{dynamic availability}:

\begin{itemize}
  \item Nodes can come online or go offline at any time.
  \item New nodes need to bootstrap from the existing chain (e.g.\ follow the longest valid chain).
  \item There is no prior knowledge of how many parties are online at any moment.
\end{itemize}

Classic BFT protocols do not handle this type of open, highly dynamic participation. :contentReference[oaicite:0]{index=0}

\subsection*{Bitcoin's Energy Problem and Motivation for PoS}

Bitcoin uses Proof-of-Work (PoW) to solve consensus in a permissionless setting, but at a high cost:

\begin{itemize}
  \item Massive energy consumption due to hash-based mining.
  \item Significant electronic waste from rapidly obsolete mining hardware.
  \item An arms race between honest miners and attackers, where both must constantly burn energy. 
\end{itemize}

Empirical studies show that the climate damages per unit of Bitcoin value can be very high (comparable to some heavy industries), motivating \textbf{more energy efficient} consensus mechanisms such as Proof-of-Stake (PoS). :contentReference[oaicite:1]{index=1}

\subsection*{Nakamoto Design Recap}

The Nakamoto-style design has three main components:

\begin{itemize}
  \item Blocks are linked in a chain via hash pointers.
  \item In case of forks, nodes adopt the chain with the most accumulated resource (e.g.\ most work).
  \item New blocks are produced by a randomized lottery that selects leaders.
\end{itemize}

In PoW, the probability of winning the lottery is proportional to hash power.  
In PoS, the idea is to make it proportional to \textbf{stake}, that is the amount of cryptocurrency controlled by a party. :contentReference[oaicite:2]{index=2}

\subsection*{Proof-of-Stake Basics}

In PoS systems:

\begin{itemize}
  \item \textbf{Stake} is the amount of tokens or coins controlled by a public key.
  \item The protocol selects block producers based on stake.
  \item Security requires that honest parties collectively control a majority of stake.
\end{itemize}

PoS is resource based but uses a \emph{digital} resource. This makes PoS energy efficient, since no physical work is required for the lottery. :contentReference[oaicite:3]{index=3}

\subsection*{Time Slots and Leader Election}

Many PoS protocols divide time into \textbf{slots}:

\begin{itemize}
  \item The slot length is chosen so that messages can propagate within one slot under the network assumptions.
  \item Ideally, one block is produced per slot.
  \item Parties use their local clock to determine the current slot and act accordingly.
\end{itemize}

Time slotting simplifies analyzing and designing leader election: in each slot, the protocol selects which stakeholders are eligible to create a block. :contentReference[oaicite:4]{index=4}

\subsection*{From PoW to PoS: Design Attempts}

We want to replace the PoW condition
\[
  H(x, s, ctr) < T
\]
with a PoS-based condition that selects leaders in proportion to stake, but without introducing new vulnerabilities.

\subsubsection*{Attempt 1: Hash with Stake-Dependent Threshold}

Require
\[
  H(x, s, vk_n) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item The right-hand side scales with the stake of node \(n\).
\end{itemize}

\textbf{Problem: Grinding Attack on \(x\)}  
The adversary can vary \(x\) (for example the transaction Merkle root) until the inequality holds, gaining unfair advantage.

\subsubsection*{Attempt 2: Remove the Dependence on Block Content}

Require
\[
  H(s, vk_n) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item Now the left-hand side no longer depends on \(x\).
\end{itemize}

\textbf{Problem: Content Malleability}  
Since transactions are not included in the hash, an attacker can change the block contents without affecting the PoS condition. This breaks ledger integrity.

\subsubsection*{Attempt 3: Bind to History with Signatures}

Keep the PoS condition similar, but add:

\begin{itemize}
  \item Use the signing key for \(vk_n\) to sign the block content and a hash of the whole history.
\end{itemize}

This prevents content malleability, because changing the history requires forging signatures.

\textbf{Problem: Posterior Corruption}  
The adversary can corrupt a leader after the fact and obtain their old signing keys, then re-sign a different history at no cost (costless simulation of the past).

\subsubsection*{Attempt 4: Key Evolving Signatures (KES)}

Introduce \textbf{Key Evolving Signatures}:

\begin{itemize}
  \item Each party periodically updates its signing key and deletes the old one.
  \item The public key is fixed but internally refers to an evolving sequence of secret keys.
  \item Old signatures remain verifiable, but old signing keys are supposed to be irretrievably erased.
\end{itemize}

This blocks posterior corruption, since even if a party is corrupted later, its previous signing keys should no longer exist.

\textbf{Problem: Adaptive Attacks}  
If the public verification key \(vk\) that will be eligible in some future slot is known in advance, an adversary can adaptively corrupt that party before it produces its block.

\subsubsection*{Attempt 5: Verifiable Random Functions (VRFs)}

Use a \textbf{VRF} in the PoS condition:

\[
  \text{VRF}(sk_n, s) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item Each party privately evaluates the VRF using its secret key.
  \item The VRF output is publicly verifiable using \(vk_n\).
  \item A party only reveals the VRF proof if it wins the slot.
\end{itemize}

This hides the leader schedule, mitigating adaptive corruptions.

\textbf{Problem: Stalling Hazard}  
If no party satisfies the inequality in a slot, no block is produced and the same inputs could be reused, potentially stalling progress.

\subsubsection*{Attempt 6: Adding Time to the VRF Input}

To prevent stalling, extend the input with a time dependent value (such as slot or timestamp):

\[
  \text{VRF}(sk_n, s \parallel ts) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item As time advances, the input changes, so the lottery is re-run with fresh randomness.
  \item Combined with KES and signatures, this forms the basis of modern PoS protocols such as Ouroboros. 
\end{itemize}

This sequence of attempts highlights subtle attack surfaces (grinding, content malleability, posterior corruption, adaptive corruption, stalling) and how PoS designs address them.

\subsection*{Dynamic Stake and Key Grinding}

In realistic systems, stake changes over time:

\begin{itemize}
  \item Tokens are transferred between accounts.
  \item New stakeholders appear and old ones may leave.
\end{itemize}

The stake distribution becomes dependent on the particular chain branch, since different branches can contain different transactions.

\textbf{Key Grinding Attack}:

\begin{itemize}
  \item Keys are generated locally and are cheap to create.
  \item An adversary can try many potential key pairs and keep those whose VRF outputs give favorable leadership schedules.
\end{itemize}

Mitigations include committing to keys before using them and deriving VRF inputs from shared randomness that is itself derived from past protocol outputs.

\subsection*{Long-Range Attacks}

A \textbf{long-range attack} exploits the fact that in PoS, creating blocks is cheap once the stake is in adversarial hands:

\begin{itemize}
  \item Starting from an old block, the adversary constructs a private fork consisting only of adversarial blocks.
  \item On that fork, the adversary accumulates all block rewards, so their stake gradually dominates.
  \item Since producing blocks has no physical cost, the adversary can simulate very long chains offline.
  \item A newly joining node that sees both the honest chain and the adversarial long fork may be fooled into adopting the wrong one.
\end{itemize}

Two main countermeasures:

\begin{itemize}
  \item \textbf{Checkpointing}: honest participants rely on external trusted checkpoints (for example, from software updates or social consensus).
  \item \textbf{Chain density}: use local density statistics to distinguish honest chains from long-range forks (for example as in Ouroboros Genesis, where the honest chain is denser shortly after forks). 
\end{itemize}

\subsection*{Permissioned Ledgers and PKI}

In a \textbf{permissioned} ledger:

\begin{itemize}
  \item Only authorized participants can produce blocks or submit transactions.
  \item The set of participants is often static and known from the genesis block.
\end{itemize}

A Public-Key Infrastructure (PKI) is used:

\begin{itemize}
  \item Certification authorities issue X.509 certificates binding public keys to identities.
  \item Nodes authenticate each other using certificates and establish secure channels (for example via TLS).
  \item Certificates can be revoked if keys are compromised or algorithms become insecure.
\end{itemize}

\subsection*{Centralized vs Distributed Permissioned Ledgers}

\textbf{Centralized permissioned ledger (PoA)}:

\begin{itemize}
  \item A single server maintains the log of transactions.
  \item Clients authenticate to the server to read or write.
  \item Correctness and liveness rely entirely on the honesty and availability of the server.
\end{itemize}

\textbf{Distributed permissioned ledger}:

\begin{itemize}
  \item Multiple servers maintain replicated copies of the log.
  \item All servers share a genesis block containing the authorized participants.
  \item Writers send their inputs to all servers.
  \item Servers run a consensus protocol to decide which inputs to append.
\end{itemize}

Access control for readers and writers can be enforced via certificates attached to the genesis block and subsequent updates. :contentReference[oaicite:12]{index=12}

\subsection*{Classical BFT Consensus vs Nakamoto Consensus}

\textbf{Classical BFT consensus}:

\begin{itemize}
  \item Typically permissioned and runs among a fixed set of nodes.
  \item Does not rely on resource assumptions such as majority hash power or stake.
  \item Communication complexity is high: all parties participate in each consensus instance.
\end{itemize}

\textbf{Nakamoto-style consensus}:

\begin{itemize}
  \item Typically permissionless.
  \item Relies on an assumption that honest nodes control a majority of some resource (hash power or stake).
  \item Communication complexity is low: only the current leader needs to broadcast its block.
\end{itemize}

\subsection*{Graded Broadcast and BFT-Ledger Construction}

A key tool in BFT protocols is \textbf{graded broadcast} (graded consensus):

\begin{itemize}
  \item There is one sender and several receivers.
  \item Each receiver outputs a pair \((M_i, G_i)\) where \(M_i\) is a message and \(G_i \in \{0,1,2\}\) is a grade.
\end{itemize}

Properties:

\begin{itemize}
  \item If the sender is honest, all honest receivers output the same message with grade 2.
  \item If some honest receiver outputs \((M, 2)\), then all honest receivers output \(M\) with grade in \(\{1,2\}\).
\end{itemize}

Graded broadcast can be implemented in three communication rounds using threshold counts of messages (at least \(2n/3\) or at least \(n/3\)), assuming fewer than \(n/3\) Byzantine faults.

By combining graded broadcast with a \textbf{binary consensus} protocol, one can build a BFT ledger where each phase appends a new block when all parties agree on the same message. :contentReference[oaicite:13]{index=13}

\subsection*{Byzantine Binary Consensus and EIG}

In \textbf{Byzantine binary consensus}, each party starts with a bit \(v_i \in \{0,1\}\) and must output a bit \(u_i\) such that:

\begin{itemize}
  \item Termination: all honest parties eventually output.
  \item Agreement: all honest parties output the same bit.
  \item Validity: if all honest parties start with the same bit \(v\), then they must output \(v\).
\end{itemize}

One generic solution uses the \textbf{Exponential Information Gathering} (EIG) algorithm:

\begin{itemize}
  \item In round 1, each party sends its input to all others.
  \item In each subsequent round, parties forward what they heard in the previous round.
  \item Each party builds a labeled tree of possible message chains and then uses majority rules bottom up to decide an output.
\end{itemize}

In the synchronous setting, EIG terminates in \(t+1\) rounds with up to \(t\) Byzantine faults, and achieves agreement and validity under appropriate bounds on \(n\) and \(t\). :contentReference[oaicite:14]{index=14}

\subsection*{Impossibility Results and Thresholds}

There are several classical impossibility results:

\begin{itemize}
  \item For synchronous systems, consensus is impossible if \(n < 3t + 1\).
  \item For asynchronous systems, deterministic consensus is impossible with even a single fault (FLP result).
  \item With cryptographic setup and signatures, some bounds can be relaxed, but there are still lower bounds on the number of rounds and required number of parties.
\end{itemize}

These results justify why Nakamoto-style protocols assume resource majority instead of attempting fully asynchronous BFT consensus. 

\subsection*{BFT-style PoS Protocols}

BFT-style PoS protocols (such as Algorand) combine PoS leader selection with BFT agreement:

\begin{itemize}
  \item In each slot, a committee of stakeholders is selected using a PoS lottery (often via VRFs).
  \item The committee runs a BFT protocol to agree on the next block.
  \item Blocks are finalized once the committee reaches agreement.
\end{itemize}

Security questions include:

\begin{itemize}
  \item How to derive secure randomness for committee selection.
  \item How to prevent grinding attacks on randomness.
  \item How to handle adaptive corruptions and long-range attacks.
\end{itemize}

\subsection*{Open Questions in Ledger Protocols}

The lecture closes with several open research questions:

\begin{itemize}
  \item How to achieve permissionless clock synchronization and ensure that parties agree on time slots.
  \item How to incentivize key erasure in KES based systems, and whether rational parties might keep old keys.
  \item Whether systems can self-heal after temporary periods in which the adversary controls a majority of the resource (stake or hash power).
\end{itemize}

These questions are central to the ongoing development of secure and robust PoS and ledger protocols. :contentReference[oaicite:16]{index=16}


\end{document}
