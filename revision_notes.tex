\documentclass[10pt,a4paper,twocolumn]{article}

\usepackage[margin=1.4cm]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{float}
\usepackage{graphicx}

% Tighter section spacing and slightly smaller titles
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{3pt}{1pt}
\titleformat{\section}{\small\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\small\bfseries}{\thesubsection}{0.5em}{}

\setlength{\parskip}{2pt}
\setlength{\parindent}{0pt}
\setlist{noitemsep,topsep=1pt,leftmargin=*}

\date{}

\begin{document}
\small

\section{Week 1}

\subsection{Why Study Blockchains}

\textbf{High level idea:} Blockchains are a new paradigm for distributed secure systems.

They combine:
\begin{itemize}
  \item Cryptography (hashes, signatures, PoW).
  \item Distributed systems (consensus, P2P networks).
  \item Economics and game theory (incentives, equilibria).
\end{itemize}

Why they matter:
\begin{itemize}
  \item Help understand modern security mechanisms:
  \begin{itemize}
    \item Key management and PKI.
    \item Software integrity and update mechanisms.
    \item Privacy enhancing technologies.
  \end{itemize}
  \item Enable new organizational forms:
  \begin{itemize}
    \item Cryptocurrency and DeFi.
    \item DAOs, on chain governance.
    \item Token based coordination and funding.
  \end{itemize}
  \item Bitcoin is a concrete proof that a large scale open system can run for years without a central operator.
\end{itemize}

\subsection{Blockchains and Distributed Ledgers}

\subsubsection{Concepts}

\textbf{Blockchain:} a distributed, append only data structure that maintains a consistent log of transactions across many nodes.

\textbf{Distributed ledger:} a general term for systems that maintain shared state among multiple parties without a single trusted authority.

Desired properties:
\begin{itemize}
  \item \textbf{Safety:} all honest nodes agree on the same history (no conflicting logs).
  \item \textbf{Liveness:} valid transactions are eventually included and confirmed.
\end{itemize}

Bitcoin is the first widely deployed blockchain protocol that achieves these properties in a permissionless setting.

\subsection{Endless Ledger Parable}

\subsubsection{Book and Scribes}

Intuition: model Bitcoin as an endlessly growing ledger maintained by many \emph{scribes}.

\begin{itemize}
  \item There is a shared ledger (a book) with many numbered pages.
  \item Anyone can become a scribe and propose a new page.
  \item Each page records a batch of transactions.
  \item The ledger never stops growing: new pages are added over time.
\end{itemize}

Constraint: adding a page requires expensive work.

\begin{itemize}
  \item To write page \(i\), the scribe must solve a hard puzzle, like throwing many dice until a rare pattern appears.
  \item This represents Proof of Work (PoW).
\end{itemize}

\subsubsection{Forks and Longest Chain Rule}

Multiple copies of the ledger may exist:

\begin{itemize}
  \item Different scribes work in parallel and may produce conflicting next pages.
  \item Question: which ledger is the ``correct'' one?
\end{itemize}

\textbf{Rule:} everyone follows the ledger with the largest number of valid pages.

\begin{itemize}
  \item If several ledgers have the same maximum length, pick the first one you received and keep writing on top of it.
  \item Pages not on the longest ledger become \emph{orphan} pages.
\end{itemize}

This is the \textbf{longest chain rule}: choose the chain with the greatest cumulative work.

\subsubsection{Randomness and Symmetry Breaking}

Each page is produced by a random process (dice throwing, PoW search):

\begin{itemize}
  \item With many scribes, the chances that two of them keep finding pages in perfect lockstep are tiny.
  \item Eventually one scribe gets ahead, creating a longer ledger.
  \item Other scribes then switch to this longer ledger.
\end{itemize}

Randomness breaks symmetry and lets the system converge on a single chain.

\subsubsection{Incentives for Scribes}

To motivate scribes to do the costly work:

\begin{itemize}
  \item The rules allow the scribe who creates a valid new page to insert a special record awarding them a reward.
  \item In Bitcoin this is the block reward (newly minted coins) plus transaction fees.
\end{itemize}

Key points:
\begin{itemize}
  \item Anyone with computing resources can become a miner.
  \item More computing power implies higher probability of winning the next block.
\end{itemize}

\subsection{Scalable Service Provision Problem}

General IT question:

\textbf{How can we scale an online service to the whole world when participants do not trust each other and there is no central authority?}

Traditional answers:
\begin{itemize}
  \item \textbf{Federation:} multiple providers cooperate (e.g. email, XMPP).
  \item \textbf{Centralization:} one dominant provider (e.g. large social networks, cloud services).
\end{itemize}

Blockchains show a third option: decentralized provision by \emph{resource owners} instead of fixed organizations.

\subsubsection{Software Only Launch (SOL)}

Goal: deploy a system purely by publishing software.

\begin{itemize}
  \item Release an open source program.
  \item Announce a start time.
  \item Anyone can download the program and run it.
  \item When enough nodes run the software, the system ``self boots'' and becomes operational.
\end{itemize}

Bitcoin is a successful example of such a software only launch.

\subsection{Hash Functions}

\subsubsection{Definition and Basic Properties}

A hash function \(H\) maps inputs of arbitrary length to fixed length outputs.

Requirements:
\begin{itemize}
  \item Efficient to compute.
  \item Output looks random and is well spread over the output space.
\end{itemize}

Cryptographic security properties:
\begin{itemize}
  \item \textbf{Pre image resistance:} given \(y\), it is hard to find any \(x\) with \(H(x) = y\).
  \item \textbf{Second pre image resistance:} given \(x\), it is hard to find \(x' \neq x\) with \(H(x') = H(x)\).
  \item \textbf{Collision resistance:} it is hard to find any pair \(x \neq x'\) such that \(H(x) = H(x')\).
\end{itemize}

\subsubsection{Birthday Paradox}

If there are \(n\) possible hash outputs, collisions appear surprisingly early.

\begin{itemize}
  \item Approximate number of random samples needed for a collision with probability \(\approx 50\%\): \(k \approx 1.177 \sqrt{n}\).
  \item For hash outputs of \(t\) bits, \(n = 2^t\), so attacks based on collisions cost about \(2^{t/2}\) operations.
\end{itemize}

\subsubsection{Examples}

\begin{itemize}
  \item Broken: MD5, SHA 1 (known collisions).
  \item Current families: SHA 2 and SHA 3 with 224, 256, 384, 512 bit outputs.
  \item Bitcoin uses SHA 256 (from SHA 2 family).
\end{itemize}

\subsection{Digital Signatures}

\subsubsection{API}

A signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\):

\begin{itemize}
  \item \textbf{KeyGen}:
  \[
    (sk, vk) \leftarrow \text{KeyGen}(1^\lambda)
  \]
  where \(sk\) is the secret signing key, \(vk\) is the public verification key.
  \item \textbf{Sign}:
  \[
    \sigma \leftarrow \text{Sign}(sk, m)
  \]
  where \(m\) is the message.
  \item \textbf{Verify}:
  \[
    b \leftarrow \text{Verify}(vk, m, \sigma) \in \{0,1\}
  \]
  output 1 (accept) or 0 (reject).
\end{itemize}

\subsubsection{Security Intuition}

Existential unforgeability under chosen message attack (EU CMA):

\begin{itemize}
  \item Attacker can obtain signatures on messages of their choice from a signing oracle.
  \item Even with this advantage, attacker should not be able to produce a valid signature on a new message that was never signed before.
\end{itemize}

\subsubsection{Constructions}

\begin{itemize}
  \item Based on RSA (integer factorization hard).
  \item Based on discrete logarithms (DSA).
  \item Elliptic curve variants (ECDSA, Schnorr).
\end{itemize}

Bitcoin uses ECDSA originally and later also supports Schnorr style signatures.

\subsection{Proof of Work (PoW)}

\subsubsection{Definition}

A PoW scheme allows a prover to demonstrate that a certain amount of computational work has been done.

Typical hash based PoW:

\[
  \text{Find } w \text{ such that } H(\text{data} \Vert w) \le T
\]
where \(T\) is a difficulty target.

\subsubsection{Simple Algorithm}

\begin{verbatim}
ctr = 0
while H(data || ctr) > T:
    ctr = ctr + 1
return ctr
\end{verbatim}

Properties:
\begin{itemize}
  \item \textbf{Fast verification:} given \(w\), one hash evaluation checks whether the condition holds.
  \item \textbf{No shortcuts:} for a well designed hash function, there is no significantly faster way than brute forcing different \(w\).
\end{itemize}

\subsubsection{Variants}

\begin{itemize}
  \item Standard Hashcash style PoW (used in Bitcoin).
  \item Memory hard PoW (e.g. scrypt, Equihash) to force large RAM usage.
  \item ASIC resistant PoW to reduce the advantage of specialized hardware.
\end{itemize}

\subsection{Resource Based Systems}

\subsubsection{Resource Types}

In resource based systems participation is tied to control of some scarce resource:

\begin{itemize}
  \item \textbf{Proof of Work (PoW):} computational power.
  \item \textbf{Proof of Stake (PoS):} ownership of currency or tokens.
  \item \textbf{Proof of Space / Capacity:} available storage.
  \item \textbf{Proof of Time / Identity:} trusted hardware or other timing assumptions.
\end{itemize}

The system is not pinned to a fixed set of identities. Instead, any entity that can show a valid proof of resource can participate in maintaining the ledger.

\subsubsection{PoW vs PoS}

\textbf{PoW:}
\begin{itemize}
  \item Pros: simple design, well studied, direct link between cost and security.
  \item Cons: high energy usage, hardware centralization (ASIC farms), environmental concerns.
\end{itemize}

\textbf{PoS:}
\begin{itemize}
  \item Pros: lower energy usage, security based on economic value at stake.
  \item Cons: subtle security issues (nothing at stake, long range attacks), more complex protocol design.
\end{itemize}

\subsection{Tokenomics}

\subsubsection{Basic Idea}

Tokenomics studies how to use tokens and rewards to align incentives of participants.

Typical cycle:
\begin{itemize}
  \item Users pay fees to use the service (transactions, smart contracts).
  \item The protocol distributes rewards to resource providers (miners, validators).
  \item Providers sell some of their tokens to cover costs and profit.
\end{itemize}

Goal: set parameters so that:
\begin{itemize}
  \item Providing honest service is economically attractive.
  \item Attacking or misbehaving is economically disfavored.
\end{itemize}

\subsection{Decentralized Service Provision}

To run a decentralized service in an open network, the protocol must handle:

\begin{itemize}
  \item \textbf{DoS resistance:} prevent abuse by spamming transactions or connections.
  \item \textbf{Consistency:} all honest participants eventually agree on the same state.
  \item \textbf{Liveness and censorship resistance:} valid transactions should not be permanently excluded.
  \item \textbf{Fairness of rewards:} contributions of resource providers should be measured and rewarded in a predictable way.
\end{itemize}

\subsubsection{Reward Sharing}

Rewards can be distributed:
\begin{itemize}
  \item Per block or per action (e.g. each mined block gets a fixed reward).
  \item Per epoch (e.g. aggregate rewards over a time window then share according to contribution).
\end{itemize}

Design challenge:
\begin{itemize}
  \item Ensure that rational, self interested participants collectively form a robust and secure system.
  \item Avoid centralization and cartel behavior where possible.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Blockchains provide a new way to build global services without central operators.
  \item The ``endless ledger'' parable explains how longest chain and randomness yield consensus.
  \item Hash functions and digital signatures are the basic cryptographic tools for integrity and authenticity.
  \item Proof of Work ties block production to computational effort and is easy to verify.
  \item Resource based systems use PoW, PoS, or other proofs to select and reward maintainers.
  \item Tokenomics and reward sharing mechanisms align incentives so that honest behavior is profitable.
\end{itemize}

\section{Week2}
\subsection{Authenticated File Storage}

\textbf{Goal:} Store a file on an untrusted server but keep only a short local state 
so that later you can check whether the server returned the correct data.

Client has identifier \(F\) and data \(D\). It sends \((F,D)\) to the server, 
and wants to delete \(D\) locally while still being able to verify any future response from the server.

\subsubsection{Naive solution (does not help)}

Client keeps a full local copy of \(D\) and checks equality with any \(D'\) returned by the server. 
This gives integrity but saves no storage.

\subsection{Basic Cryptographic Tools}

\subsubsection{Hash-based authentication}

Hash function \(H\) is collision resistant.

\begin{itemize}
  \item Upload: client sends \((F,D)\) to server.
  \item Commit: client stores only \(h = H(D)\), deletes \(D\).
  \item Retrieval: server returns \(D'\).
  \item Verify: client accepts if \(H(D') = h\), rejects otherwise.
\end{itemize}

Properties:
\begin{itemize}
  \item Client keeps a short fixed-size value.
  \item Integrity relies on collision resistance of \(H\).
\end{itemize}

\subsubsection{Digital signatures}

Signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\).

\begin{itemize}
  \item Key generation: client runs \(\text{KeyGen}\) to get \((sk, vk)\).
  \item Upload: compute \(\sigma = \text{Sign}(sk,\langle F,D\rangle)\), send \((F,D,\sigma)\) 
  to server.
  \item Client keeps only \(vk\).
  \item Retrieval: server returns \((D',\sigma')\).
  \item Verify: accept if \(\text{Verify}(vk,\langle F,D'\rangle,\sigma') = 1\).
\end{itemize}

Difference from pure hashing:
\begin{itemize}
  \item Signatures are publicly verifiable (third parties can check).
  \item Useful for transferable proofs of origin and integrity.
\end{itemize}

\subsection{Merkle Trees}

\subsubsection{Structure}

Goal: authenticate large data split into blocks, and allow efficient verification of 
individual blocks.

\begin{itemize}
  \item Split data \(D\) into blocks \(D_1,\dots,D_n\).
  \item Compute leaf hashes \(H_1 = H(D_1),\dots,H_n = H(D_n)\).
  \item Build a binary tree:
    \[
      H_{i,j} = H(H_i \Vert H_j)
    \]
    up to a single \emph{Merkle root} \(MTR\).
\end{itemize}

Client stores only \(MTR\) as the commitment to the entire file.

\subsubsection{Merkle-based storage protocol}

\begin{itemize}
  \item Upload: client sends full \(D\) to server, builds Merkle tree locally and 
  computes root \(MTR\), then keeps only \(MTR\).
  \item Retrieval of a block \(D_x\): server returns \(D_x\) and 
  a \emph{proof of inclusion} \(\pi\).
  \item Verification: client uses \(D_x\), \(\pi\), and \(H\) to recompute 
  a root and checks that it equals stored \(MTR\).
\end{itemize}

\subsubsection{Proof of inclusion}

For a block \(D_x\):
\begin{itemize}
  \item Proof consists of all sibling hashes along the path from the leaf \(H(D_x)\) to the root.
  \item Verifier:
    \begin{enumerate}
      \item Starts from \(H(D_x)\).
      \item Iteratively combines with sibling hashes and hashes upward.
      \item Checks whether the final value equals \(MTR\).
    \end{enumerate}
\end{itemize}

Tree height is \(O(\log n)\) for \(n\) leaves, so proof size and verification time are \(O(\log n)\).

\subsubsection{Applications}

\begin{itemize}
  \item BitTorrent: verify file chunks during download.
  \item Bitcoin: Merkle tree of transactions inside each block.
  \item Ethereum: variants of Merkle trees for state and transactions.
\end{itemize}

\subsection{Merkle Trees for Sets}

Goal: store a set \(S\) on a server and later prove membership or non-membership of any element \(x\).

Construction:
\begin{itemize}
  \item Sort the elements of \(S\).
  \item Build a Merkle tree where leaves are sorted elements.
\end{itemize}

\subsubsection{Membership proof}

If \(x \in S\), the server provides a normal proof of inclusion for the leaf corresponding to \(x\).

\subsubsection{Non-membership proof}

If \(x \notin S\):
\begin{itemize}
  \item Find neighbors \(H_{<}\) and \(H_{>}\) in the sorted order such that \(H_{<} < x < H_{>}\).
  \item Provide inclusion proofs for \(H_{<}\) and \(H_{>}\).
  \item Show they are adjacent in the sorted set representation.
  \item Conclude that \(x\) is not present.
\end{itemize}

\subsection{Tries and Patricia Tries}

\subsubsection{Trie (prefix tree)}

Data structure for a set of key-value pairs \(\{(key,value)\}\) where keys are strings.

\begin{itemize}
  \item Each edge is labeled with a character.
  \item A path from the root spells out a key.
  \item Nodes may store values for keys ending at that node.
\end{itemize}

Operations:
\begin{itemize}
  \item \textbf{add(key,value)}: follow or create edges for each character, 
  then store the value at the final node.
  \item \textbf{query(key)}: follow edges by characters, and check whether 
  the final node has a value.
\end{itemize}

\subsubsection{Patricia Trie}

Compressed version of a Trie:
\begin{itemize}
  \item Any chain of nodes where each node has a single child and no value 
  can be merged into a single edge labeled with a substring.
  \item Saves space and reduces tree height.
\end{itemize}

Patricia tries are widely used in blockchain systems for efficient key-value storage.

\subsection{Merkle Patricia Trie (MPT)}

Ethereum combines Merkle hashing with Patricia tries.

\subsubsection{Node types}

Keys are encoded in hexadecimal nibbles. There are three logical node types:


\begin{itemize}
  \item \textbf{Leaf node}: stores remaining key fragment and the value.
  \item \textbf{Extension node}: stores a shared key prefix and a pointer to another node.
  \item \textbf{Branch node}: has up to 16 child pointers (for hex digits) plus an optional value.
\end{itemize}

Each logical node is serialized and hashed. Child pointers store the hash of the child node, 
so the root hash commits to the entire key-value map.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_merkle_paricia_trie.png}
\end{figure}


\subsubsection{Properties}

\begin{itemize}
  \item Root hash acts as a commitment to the whole dictionary.
  \item Inclusion proofs: show the path from the root down to a leaf and the content of 
  intermediate nodes.
  \item Non-inclusion proofs: show that the search path terminates at a node that proves 
  no matching key exists.
  \item Ethereum uses an MPT for the global world state, and the state root hash is stored 
  in the block header.
\end{itemize}

\subsection{Blockchain Data Structures}

\subsubsection{Block structure}

A block consists of:
\begin{itemize}
  \item Random nonce \(\text{ctr}\).
  \item Data \(x\) (e.g. transactions, root hashes).
  \item Pointer \(s\) to the previous block (usually a hash of the previous header).
\end{itemize}

The header typically includes \((\text{ctr}, x, s)\). The pointer field \(s\) creates a hash 
chain of blocks back to the genesis block.

\subsubsection{Proof of Work (PoW)}

In PoW systems a block header must satisfy:
\[
  H(\text{ctr} \Vert x \Vert s) \le T
\]
where \(T\) is a global difficulty target.

\begin{itemize}
  \item Miners fix \(x\) and \(s\), iterate over \(\text{ctr}\), and search for a header whose 
  hash is below \(T\).
  \item The same hash is also used as the block identifier.
\end{itemize}

\subsection{Bitcoin Overview}

\subsubsection{High-level protocol}

\begin{enumerate}
  \item New transactions are broadcast to the network.
  \item Nodes collect transactions into candidate blocks.
  \item Nodes perform PoW to find valid blocks.
  \item A node that finds a valid block broadcasts it.
  \item Other nodes validate all transactions and the PoW before accepting.
  \item Nodes start mining on top of the longest valid chain.
\end{enumerate}

\subsubsection{UTXO model}

Bitcoin represents ownership via unspent transaction outputs (UTXOs).

\begin{itemize}
  \item A transaction has multiple inputs and outputs.
  \item Each \textbf{input} references a previous output (by transaction hash and index) and 
  provides a script that authorizes spending.
  \item Each \textbf{output} specifies a value and a script defining how it may be spent in the future.
\end{itemize}

\subsubsection{Scripts}

Typical pay-to-public-key-hash (P2PKH) transaction:

\begin{itemize}
  \item Output script (\texttt{scriptPubKey}): 
  \begin{align*}
    \text{OP\_DUP}\ \text{OP\_HASH160}\ \langle \text{pubKeyHash} \rangle \\
    \text{OP\_EQUALVERIFY}\ \text{OP\_CHECKSIG}
  \end{align*}
  
  \item Input script (\texttt{scriptSig}) when spent: 
  \[
    \langle sig \rangle\ \langle pubKey \rangle
  \]
\end{itemize}

During validation, the combined script is executed to check that the spender owns the 
corresponding private key.

\subsubsection{Merkle tree of transactions in a block}

\begin{itemize}
  \item All transactions in a block are organized as a Merkle tree.
  \item The Merkle root is stored in the block header.
  \item Simplified payment verification (SPV) clients download only block headers and 
  proofs of inclusion for specific transactions.
\end{itemize}

\subsection{Bitcoin Network}

\subsubsection{P2P topology}

\begin{itemize}
  \item All nodes run the same open-source protocol.
  \item Each node maintains connections to a set of peers.
  \item The network is permissionless: nodes may join or leave at any time.
\end{itemize}

Bootstrapping:
\begin{itemize}
  \item Peer-to-peer nodes come “pre-installed” with some peers by IP / host.
  \item A user can also manually configure known peers.
\end{itemize}

\subsubsection{Gossip protocol}

\begin{itemize}
  \item When a node learns about a new transaction or block, it forwards it to its peers.
  \item Each peer that sees a new item forwards it to its own peers.
  \item Nodes ignore items they have already seen.
  \item This peer-to-peer diffusion eventually spreads data to most honest nodes.
\end{itemize}

\subsubsection{Eclipse attacks and connectivity assumption}

\textbf{Connectivity assumption}: every honest node can reach every other honest node 
through some path in the network.

\textbf{Eclipse attack}:
\begin{itemize}
  \item Attacker surrounds a victim with malicious peers.
  \item Victim only connects to attacker-controlled nodes and is cut off from the honest network.
  \item This can delay or hide blocks and transactions, enabling double spending or 
  inconsistent views.
\end{itemize}

Maintaining good connectivity and diverse peer sets is critical for blockchain security.

\subsection{Quick Summary}

\begin{itemize}
  \item Hashes and signatures support basic authenticated storage.
  \item Merkle trees give efficient proofs of inclusion with size \(O(\log n)\).
  \item Merkle trees extend to sets and enable non-membership proofs.
  \item Tries store key-value maps by sharing prefixes; Patricia tries compress long paths.
  \item Merkle Patricia tries combine hashing and compressed tries; Ethereum uses them for state.
  \item Blockchain data structures link blocks using hash pointers and PoW.
  \item Bitcoin uses UTXOs, scripts, Merkle trees of transactions, and a P2P gossip network.
\end{itemize}

\section{Week 3}

\subsection{Smart Contracts: Concept}

\textbf{Smart contract:} a computer program that runs on the blockchain.

\begin{itemize}
  \item Code is stored on chain and executed by all full nodes.
  \item Execution is deterministic: all honest nodes get the same outcome.
  \item Code can read:
  \begin{itemize}
    \item Its own internal storage.
    \item Transaction context (sender, value, data).
    \item Recent block data (in Ethereum).
  \end{itemize}
  \item Code of a deployed contract cannot change (immutability).
\end{itemize}

Legal caution: from a legal point of view, ``smart contracts'' are usually neither legally smart nor contracts; they are programs enforcing some rules on chain.

\subsection{Bitcoin Transactions and Script}

\subsubsection{Transaction structure}

A Bitcoin transaction consists of:

\begin{itemize}
  \item \textbf{Inputs}:
  \begin{itemize}
    \item Reference to a previous transaction output (tx hash + index).
    \item \texttt{scriptSig}: unlocking script that proves right to spend.
  \end{itemize}
  \item \textbf{Outputs}:
  \begin{itemize}
    \item \texttt{value}: amount of BTC.
    \item \texttt{scriptPubKey}: locking script specifying spending conditions.
  \end{itemize}
\end{itemize}

Validation rule: for each input, the node executes
\[
\texttt{scriptSig} \Vert \texttt{scriptPubKey}
\]
on a stack machine and checks that it finishes with value \texttt{TRUE} on top of the stack.

\subsubsection{Bitcoin Script basics}

\begin{itemize}
  \item Stack based, not Turing complete.
  \item Data (e.g. \texttt{<sig>}, \texttt{<pubKey>}) is pushed to the stack.
  \item \textbf{Opcodes}:
  \begin{itemize}
    \item Arithmetic: \texttt{OP\_ADD}, \texttt{OP\_ABS}, \dots
    \item Stack operations: \texttt{OP\_DROP}, \texttt{OP\_SWAP}.
    \item Comparisons: \texttt{OP\_EQUAL}, \texttt{OP\_EQUALVERIFY}.
    \item Crypto: \texttt{OP\_HASH160}, \texttt{OP\_SHA256}.
    \item Signatures: \texttt{OP\_CHECKSIG}, \texttt{OP\_CHECKMULTISIG}.
    \item Timelocks: \texttt{OP\_CHECKLOCKTIMEVERIFY}, \texttt{OP\_CHECKSEQUENCEVERIFY}.
  \end{itemize}
\end{itemize}

\subsubsection{P2PKH example}

\textbf{Output script (\texttt{scriptPubKey}):}
\[
\texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
\]

\textbf{Input script (\texttt{scriptSig}) when spending:}
\[
\texttt{<sig> <pubKey>}
\]

Execution steps:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/btc_script_example.png}
\end{figure}

\subsection{Limitations of Bitcoin Script}

\begin{itemize}
  \item \textbf{No loops} and restricted control flow: not Turing complete.
  \item \textbf{No internal state}: script cannot store persistent variables.
  \item \textbf{Value blind}: script cannot inspect the exact amount being sent, it just validates spending conditions.
  \item \textbf{Blockchain blind}: cannot access block header fields (e.g. nonce, previous hash) except for basic locktime operations.
\end{itemize}

These limitations make Bitcoin simple and secure but restrict expressiveness.

\subsection{Extending Bitcoin Functionality}

Two main options:

\subsubsection{Build on top of Bitcoin}

\begin{itemize}
  \item Use Bitcoin as a base layer and encode extra logic at a higher protocol layer.
  \item Pros: reuses existing security and mining power; cheaper to deploy.
  \item Cons: limited flexibility because higher layer must respect Bitcoin's script and transaction model.
\end{itemize}

\subsubsection{Build an independent blockchain}

\begin{itemize}
  \item Design a new protocol from scratch (e.g. Ethereum).
  \item Pros: can add new opcodes and richer state; more expressive smart contracts.
  \item Cons: must bootstrap own validators or miners; higher development and maintenance cost.
\end{itemize}

\subsection{Ethereum Overview}

Ethereum keeps the blockchain idea but turns it into a \textbf{universal replicated state machine}.

\begin{itemize}
  \item One global state shared by all nodes.
  \item Transactions are state transition requests.
  \item A virtual machine (EVM) applies transactions to the state.
  \item Turing complete bytecode language for smart contracts.
  \item Decentralized applications (DApps) can be deployed and executed on chain.
\end{itemize}

Consensus and Sybil resistance:

\begin{itemize}
  \item Originally Proof of Work (Ethash), now Proof of Stake (validators, staking, Gasper).
\end{itemize}

\subsection{Ethereum Accounts}

\subsubsection{Global state}

Ethereum's global state is a mapping from 20-byte addresses to account objects.

Each account has:

\begin{itemize}
  \item \texttt{address}: 160-bit identifier.
  \item \texttt{balance}: amount of Ether (in wei).
  \item \texttt{nonce}: number of sent transactions.
  \item (for contract accounts) \texttt{code} and \texttt{storage}.
\end{itemize}

\subsubsection{Two types of accounts}

\textbf{Externally Owned Account (EOA):}

\begin{itemize}
  \item Address is derived from a public key: \(\text{addr} = H(\text{pubKey})\).
  \item Controlled by a private key held by a user.
  \item No code or storage.
\end{itemize}

\textbf{Contract account:}

\begin{itemize}
  \item Address is derived from creator address and nonce.
  \item Contains immutable contract code and persistent storage.
  \item Cannot initiate transactions on its own; reacts to incoming transactions or messages.
\end{itemize}

\subsubsection{UTxO vs account model}

\begin{itemize}
  \item UTxO:
  \begin{itemize}
    \item Better for privacy and parallelism.
    \item Outputs are spent or unspent.
  \end{itemize}
  \item Account model (Ethereum):
  \begin{itemize}
    \item Conceptually simpler.
    \item More compact representation of balances and state.
  \end{itemize}
\end{itemize}

\subsection{Ethereum Transactions}

A transaction includes:

\begin{itemize}
  \item \texttt{from}: recovered from the signature (sender's address).
  \item \texttt{to}: recipient address (EOA or contract). If empty, this is a contract creation tx.
  \item \texttt{value}: amount of Ether in wei.
  \item \texttt{data}: payload. For contracts this encodes which function to call and its arguments. Empty for simple ETH transfers.
  \item \texttt{nonce}: counts how many transactions the sender has already sent, prevents replay.
  \item \texttt{gasLimit} (\texttt{startgas}): maximum gas units the sender is willing to use.
  \item \texttt{gasPrice}: price per gas unit (or fee parameters in newer fee model).
  \item \texttt{signature}: proves authorization by the sender.
\end{itemize}

\subsubsection{Types of transactions}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_tx_types.png}
\end{figure}

\subsection{Ethereum Block Structure and Production}

\subsubsection{Block header format}

Each Ethereum block contains the list of transactions and a commitment to the most recent global state.

The block header stores:

\begin{itemize}
  \item \textbf{prev}: hash pointer to the previous block.
  \item \textbf{hash}: block hash (identifier).
  \item \textbf{time}: block timestamp.
  \item \textbf{gasLimit}: maximum total gas allowed in the block.
  \item \textbf{gasUsed}: total gas consumed by included transactions.
  \item \textbf{nonce}: used in the old PoW design (no longer relevant under PoS).
  \item \textbf{difficulty}: PoW difficulty (historical field).
  \item \textbf{miner}: address of the block proposer (validator under PoS).
  \item \textbf{extra}: optional metadata.
  \item \textbf{state root}: Merkle Patricia Trie root of the global account state.
  \item \textbf{transaction root}: Merkle root of all transactions in this block.
  \item \textbf{receipt root}: Merkle root of all transaction receipts (status, logs, gas usage).
\end{itemize}

The \textbf{state root} commits to all accounts, where each account record contains:
\begin{itemize}
  \item \textbf{address}
  \item \textbf{code} (empty for EOAs)
  \item \textbf{storage} (persistent key/value data)
  \item \textbf{balance} (in wei)
  \item \textbf{nonce} (number of sent transactions)
\end{itemize}

\subsubsection{Block production and rewards}

\begin{itemize}
  \item Blocks contain: the ordered transaction list and the most recent state (via the state root).
  \item Typical block time: about \textbf{12 seconds}.
  \item Since 2022, Ethereum uses \textbf{Proof-of-Stake (Gasper)} for Sybil resistance and consensus.
  \item Previously, Ethereum used \textbf{Proof-of-Work} with Ethash (memory-hard PoW).
\end{itemize}

Rewards and fees:

\begin{itemize}
  \item \textbf{Before the Merge (PoW):} block miner received a fixed block reward (e.g.\ 2 ETH) plus all transaction fees.
  \item \textbf{After the Merge (PoS):}
  \begin{itemize}
    \item The block proposer (validator) receives a \textbf{base block reward} (newly issued ETH), depending on total ETH staked.
    \item Each transaction has a \textbf{base fee} which is \emph{burned}, reducing total ETH supply.
    \item Users can add \textbf{priority fees (tips)} that are paid directly to the block proposer.
  \end{itemize}
\end{itemize}


\subsection{Messages between contracts}

Contracts cannot create real transactions, but can send \emph{messages}:

\begin{itemize}
  \item Messages are internal calls generated by running contract code.
  \item They exist only inside EVM execution and are not part of the P2P network.
  \item A message can transfer ETH and call functions of other contracts.
\end{itemize}

Execution chain:

\begin{itemize}
  \item External transaction triggers code of a contract.
  \item That contract can send messages to other contracts.
  \item Each recipient runs its code in turn.
\end{itemize}

\subsection{Ethereum Virtual Machine (EVM)}

\begin{itemize}
  \item Stack based architecture with 1024-element stack of 256-bit words.
  \item Bytecode instruction set; each opcode has a defined gas cost.
  \item Three data areas:
  \begin{itemize}
    \item \textbf{Stack}: last-in first-out, used for intermediate values.
    \item \textbf{Memory}: transient byte array, cleared between transactions.
    \item \textbf{Storage}: persistent key-value store, written to and read by contract code.
  \end{itemize}
  \item Crypto primitives: hash functions, signature verification.
  \item Can read execution context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{block.timestamp}, etc.
\end{itemize}

\subsection{Gas and Transaction Fees}

\subsubsection{Why gas is needed}

\begin{itemize}
  \item Every node must execute all transactions and keep the full state.
  \item Without limits, a malicious contract could run forever (halting problem).
  \item Gas sets a hard bound on how much computation and storage a transaction may consume.
\end{itemize}

\subsubsection{Gas fields in a transaction}

\begin{itemize}
  \item \textbf{Gas limit} (\texttt{startgas}): maximum gas units the sender allows for this transaction.
  \item \textbf{Gas price}: price per gas unit in wei (or equivalent fee parameters).
\end{itemize}

Maximum fee the sender is willing to pay is:
\[
\text{maxFee} = \text{gasLimit} \times \text{gasPrice}.
\]

\subsubsection{Execution with gas}

Simplified algorithm for a transaction:

\begin{enumerate}
  \item Check that \(\text{gasLimit} \times \text{gasPrice} \le \text{balance}\). If not, reject.
  \item Deduct \(\text{gasLimit} \times \text{gasPrice}\) from sender balance.
  \item Set \texttt{gas} \(\leftarrow \text{gasLimit}\).
  \item Execute bytecode, decreasing \texttt{gas} by the cost of each operation.
  \item If execution finishes normally, refund unused gas:
  \[
  \text{refund} = \text{gasRemaining} \times \text{gasPrice}.
  \]
  \item If gas reaches zero before finishing (out of gas), revert state changes. The prepaid fee is not refunded.
\end{enumerate}

Note: blocks also have a \emph{block gas limit}, so the sum of gas used by all transactions in a block cannot exceed this bound.

\subsection{Introduction to Solidity}

Solidity is a high level language that compiles to EVM bytecode.

\begin{itemize}
  \item Syntax resembles JavaScript.
  \item Statically typed: every variable must have an explicit type.
  \item Supports contracts, state variables, functions, events, modifiers, inheritance, and interfaces.
\end{itemize}

\subsubsection{Basic contract example}

A minimal contract usually:

\begin{itemize}
  \item Starts with a \texttt{pragma} line specifying the compiler version range.
  \item Declares a \texttt{contract} with a name.
  \item Contains one or more functions. For example, a simple contract \texttt{HelloWorld} may have a \texttt{print} function marked \texttt{public} and \texttt{pure} that returns the string \texttt{"Hello World!"}.
\end{itemize}

\subsection{Solidity: Variables and Types}

\subsubsection{State vs local variables}

\begin{itemize}
  \item \textbf{State variables}:
  \begin{itemize}
    \item Declared at contract level.
    \item Stored in contract storage (persistent and expensive to change).
  \end{itemize}
  \item \textbf{Local variables}:
  \begin{itemize}
    \item Declared inside functions.
    \item Live only during function execution.
    \item Value types are kept on the stack; reference types require an explicit data location.
  \end{itemize}
\end{itemize}

\subsubsection{Value types}

\begin{itemize}
  \item \textbf{bool}: \texttt{true} or \texttt{false}.
  \item \textbf{int} and \textbf{uint}: signed and unsigned integers of 8 to 256 bits (e.g.\ \texttt{uint256}, \texttt{int8}).
  \item \textbf{address}: 20-byte address; \texttt{address payable} can receive Ether.
  \item \textbf{bytes1} to \textbf{bytes32}: fixed size byte arrays.
  \item \textbf{enum}: user defined type with a finite set of named values.
\end{itemize}

Variables without explicit initialization receive the default zero value for their type.

\subsubsection{Reference types}

\begin{itemize}
  \item Dynamic arrays: \texttt{uint[]} or \texttt{bytes} or \texttt{string}.
  \item Static arrays: for example, \texttt{uint[5]}.
  \item \textbf{mapping(KeyType => ValueType)}: key-value dictionary, non-iterable.
  \item \textbf{struct}: groups multiple fields into one type, e.g.\ a \texttt{Voter} struct with fields for weight, address, and whether they have voted.
\end{itemize}

\subsection{Visibility and Function Types}

\subsubsection{Visibility of functions and variables}

\begin{itemize}
  \item \textbf{public}:
  \begin{itemize}
    \item Functions callable from outside and inside contracts.
    \item For public state variables, the compiler generates a getter automatically.
  \end{itemize}
  \item \textbf{external}:
  \begin{itemize}
    \item Callable only from outside the contract.
    \item Cannot be used for state variables.
  \end{itemize}
  \item \textbf{internal}:
  \begin{itemize}
    \item Callable only inside the contract or from derived contracts.
  \end{itemize}
  \item \textbf{private}:
  \begin{itemize}
    \item Callable only inside the contract that defines them (not visible in children).
  \end{itemize}
\end{itemize}

\subsubsection{Function modifiers (state mutability)}

\begin{itemize}
  \item \textbf{view}: function promises not to modify state, but may read it.
  \item \textbf{pure}: function promises not to read or modify state (depends only on its arguments).
  \item \textbf{payable}: function can receive Ether along with the call.
\end{itemize}

Remember: on-chain data is publicly visible regardless of visibility keywords; these only restrict who can \emph{invoke} a function.

\subsection{Solidity Inheritance and Interfaces}

\begin{itemize}
  \item Solidity supports multiple inheritance between contracts.
  \item The keyword \texttt{is} is used to derive one contract from another.
  \item Derived contracts can access non-\texttt{private} state and internal functions of parents.
  \item Interfaces are abstract contracts that only declare function signatures (no implementation). Implementing contracts must provide the body of each function.
\end{itemize}

Typical pattern:

\begin{itemize}
  \item Define an interface \texttt{Regulator} that specifies functions like \texttt{checkValue} and \texttt{loan}.
  \item Implement a concrete \texttt{Bank} contract \texttt{is Regulator} that maintains an internal balance, implements deposit/withdraw functions, and provides concrete definitions of \texttt{checkValue} and \texttt{loan}.
\end{itemize}

\subsection{Data Location: storage, memory, calldata}

\begin{itemize}
  \item \textbf{storage}:
  \begin{itemize}
    \item Persistent key-value store for state variables.
    \item Expensive to read and write; changes are stored on chain.
  \end{itemize}
  \item \textbf{memory}:
  \begin{itemize}
    \item Temporary area for reference types inside functions.
    \item Cleared after the function ends.
  \end{itemize}
  \item \textbf{calldata}:
  \begin{itemize}
    \item Read-only location for function arguments of external functions.
    \item Cheaper than memory for dynamic types.
  \end{itemize}
\end{itemize}

Assignment behaviour:

\begin{itemize}
  \item \texttt{storage} $\leftrightarrow$ \texttt{memory}: data is copied.
  \item \texttt{memory} $\leftrightarrow$ \texttt{memory}: references are passed.
  \item Local variables of type \texttt{storage} act as references (aliases) to existing state variables.
\end{itemize}

\subsection{Events and Modifiers}

\subsubsection{Events}

\begin{itemize}
  \item Provide a logging mechanism inside the EVM.
  \item Event arguments are stored in the transaction log, not in contract storage.
  \item Off-chain clients (e.g.\ in JavaScript or Python) can subscribe to events and react to them.
  \item A typical pattern is an event such as \texttt{Deposit(from, id, value)} emitted whenever Ether is deposited into the contract.
\end{itemize}

\subsubsection{Modifiers}

\begin{itemize}
  \item Modifiers are reusable preconditions or wrappers around functions.
  \item The body of the modifier is injected at the point where \texttt{\_;} appears.
  \item Common example: an \texttt{onlyOwner} modifier that checks \texttt{msg.sender == owner} before executing the function body.
  \item A contract \texttt{Owned} may set the \texttt{owner} to the deployer in the constructor and define \texttt{onlyOwner}; a derived contract \texttt{Mortal} can then protect a \texttt{close} function with this modifier.
\end{itemize}

\subsection{Global Variables and Units}

\subsubsection{Ether units}

\begin{itemize}
  \item \texttt{1 ether == 10\string^18 wei}.
  \item Other common units: \texttt{wei}, \texttt{gwei}, \texttt{szabo}, \texttt{finney}.
\end{itemize}

\subsubsection{Time units}

\begin{itemize}
  \item Suffixes: \texttt{seconds}, \texttt{minutes}, \texttt{hours}, \texttt{days}, \texttt{weeks}.
  \item Example: \texttt{1 hours == 60 minutes}.
\end{itemize}

\subsubsection{Common global variables}

\begin{itemize}
  \item Block properties: \texttt{block.timestamp}, \texttt{block.number}, \texttt{block.coinbase}.
  \item Transaction and message context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{msg.data}, \texttt{tx.origin}.
  \item Address helpers: \texttt{addr.balance}, \texttt{addr.transfer(...)}, \texttt{addr.call(...)}.
\end{itemize}

\subsection{Fallback and Receive Functions}

\begin{itemize}
  \item \texttt{receive()}:
  \begin{itemize}
    \item Declared as \texttt{receive() external payable}.
    \item Executed when the contract receives Ether with empty data.
  \end{itemize}
  \item \texttt{fallback()}:
  \begin{itemize}
    \item Declared as \texttt{fallback() external} (optionally \texttt{payable}).
    \item Executed when no other function matches the call data, or when data is non-empty and \texttt{receive} does not exist.
  \end{itemize}
  \item Both functions should be simple and use little gas to avoid unexpected failures.
\end{itemize}

\subsection{Sending Ether: transfer, send, call}

\begin{itemize}
  \item \texttt{transfer}:
  \begin{itemize}
    \item Forwards 2300 gas to the recipient.
    \item Reverts on failure.
    \item Historically considered safe against re-entrancy because the gas stipend is small.
  \end{itemize}
  \item \texttt{send}:
  \begin{itemize}
    \item Also forwards 2300 gas.
    \item Returns a boolean success flag instead of reverting; caller must check it.
  \end{itemize}
  \item Low-level \texttt{call} with value:
  \begin{itemize}
    \item Can send Ether and forward an arbitrary amount of gas.
    \item Returns a success flag and returned data.
    \item Flexible but vulnerable to re-entrancy if state updates and external calls are not ordered carefully.
  \end{itemize}
\end{itemize}

Best practice: use \texttt{call} together with the checks--effects--interactions pattern and, if needed, explicit re-entrancy guards.

\subsection{Interacting with Other Contracts}

\begin{itemize}
  \item Contracts can create new contracts and call existing ones.
  \item A typical pattern: a ``factory'' contract that deploys new instances of another contract (e.g.\ \texttt{Universe} creating many \texttt{Planet} contracts), stores their addresses in an array, and emits an event each time a new instance is created.
  \item Interaction is done by using the other contract's type and calling its functions as methods.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Bitcoin uses a stack based, non Turing complete scripting system to authorise spending of UTxOs.
  \item Ethereum generalises blockchains into a universal replicated state machine with accounts, contracts, and global state.
  \item The EVM is a stack machine with storage, memory, and stack; gas ensures that computation is bounded and paid for.
  \item Solidity is a high level language for writing contracts, with explicit types, visibility, data locations, and support for inheritance.
  \item Events, modifiers, and global variables are key tools for building practical contracts.
  \item Ether transfers use \texttt{transfer}, \texttt{send}, or \texttt{call}; understanding their differences is important for security.
\end{itemize}


\section{Week 4}

\subsection{Lecture Overview}
This lecture focuses on identifying security hazards in smart contracts and designing safer contract architectures. We examine four main attack vectors:
\begin{itemize}
    \item Denial-of-Service (DoS)
    \item Griefing attacks
    \item Reentrancy attacks
    \item Front-running
\end{itemize}

Key defensive patterns include Pull-over-Push, Checks--Effects--Interactions, safe fallback design, avoiding \texttt{tx.origin}, safe randomness, and overflow/underflow protection.

\subsection{Denial-of-Service and Griefing}

\textbf{Unbounded loops} can make functions impossible to execute once arrays grow large.
Example insecure pattern:
\begin{verbatim}
for (uint i=0; i<investors.length; i++) {
    investors[i].addr.send(investors[i].dividendAmount);
}
\end{verbatim}

As the array size increases, gas requirements exceed block limits, leading to DoS.  
Griefing attacks intentionally exploit this by causing certain \texttt{send()} calls to fail, blocking all refunds.

\textbf{Solution: Pull-over-Push}.  
Instead of transferring funds inside a loop, store refund balances and allow users to withdraw individually.
\begin{verbatim}
// Pull model
refunds[user] += amount;
function withdrawRefund() external {
    uint r = refunds[msg.sender];
    refunds[msg.sender] = 0;
    msg.sender.transfer(r);
}
\end{verbatim}

\subsection{Reentrancy Attacks}

A reentrancy attack occurs when an external call triggers a fallback function that re-enters the vulnerable contract before state updates occur.

\textbf{Vulnerable pattern:}
\begin{verbatim}
uint amount = balances[msg.sender];
require(msg.sender.call.value(amount)());
balances[msg.sender] = 0;
\end{verbatim}

Attackers repeatedly drain funds through recursive fallback calls.  
The DAO attack (2016) exploited this weakness, resulting in a \$50M loss.

\textbf{Mitigation: Checks--Effects--Interactions.}
\begin{verbatim}
uint amount = balances[msg.sender];
balances[msg.sender] = 0;
msg.sender.transfer(amount);
\end{verbatim}

Additional protections: mutex locks, Pull-over-Push pattern.

\subsection{Solidity-Specific Hazards}

\textbf{Forcibly sending Ether}.  
Ether can be sent to a contract without triggering fallback functions, e.g.:
\begin{itemize}
    \item \texttt{selfdestruct(target)}
    \item precomputed contract addresses
    \item block reward redirection
\end{itemize}
Thus, do not rely on strict balance equality.

\textbf{4.2 Delegatecall hazards}.  
\texttt{delegatecall} uses the caller's storage and \texttt{msg.sender}.  
Malicious libraries can overwrite critical variables like \texttt{owner}.

\textbf{4.3 Misuse of \texttt{tx.origin}}.  
Using \texttt{tx.origin} for authorization enables phishing attacks. Always use \texttt{msg.sender}.

\textbf{4.4 Fallback complexity}.  
Fallback functions should contain minimal logic to avoid vulnerabilities such as reentrancy.

\textbf{4.5 Default values}.  
Uninitialized mapping entries return default values (e.g., 0).  
Incorrect handling led to the Nomad Bridge hack (2022).

\subsection{Merkle Tree Vulnerabilities}

Sparse Merkle Trees assign empty values to uninitialized leaves, enabling forged proofs.  
Binance Bridge was exploited through a manipulated AVL Merkle proof.  
Avoid custom cryptographic implementations unless formally verified.

\subsection{Front-running Attacks}

Miners reorder transactions by gas price.  

Example:
\begin{verbatim}
registerName("alice")
\end{verbatim}
An attacker sends:
\begin{verbatim}
registerName("alice") // higher gas price
\end{verbatim}

\textbf{Commit--Reveal Scheme} prevents this:
\begin{itemize}
    \item Commit: \texttt{hash(value, nonce)}
    \item Reveal later
    \item Verify hash
\end{itemize}

\subsection{Randomness Hazards}

Sources like \texttt{block.timestamp}, \texttt{block.number}, \texttt{blockhash}, \texttt{msg.sender} are predictable or miner-controlled.

Future blockhash is also insecure because miners can withhold or reorder blocks.

\textbf{Secure randomness: Commit--Reveal}.  
Both parties commit to random values, reveal later, then combine (e.g., XOR).  
If either party is honest, randomness is secure.

\subsection{Integer Overflow and Underflow}

Prior to Solidity~0.8, arithmetic did not include overflow checks.  
Example:
\begin{verbatim}
balance[msg.sender] -= value;
\end{verbatim}

Mitigation:
\begin{itemize}
    \item Use Solidity 0.8+ (automatic checks)
    \item Use SafeMath for older versions
\end{itemize}

\subsection{Gas Fairness}

Depending on contract design:
\begin{itemize}
    \item Last contributor may pay all gas
    \item Beneficiary may pay
    \item All parties may share costs
\end{itemize}

Fairness must be considered in crowdfunding or payout logic.

\subsection{Example of an Insecure Contract}

The Rock--Paper--Scissors example demonstrates:
\begin{itemize}
    \item Commit has no nonce, so the commitment \texttt{sha256(hand)} can be brute-forced (only 3 possibilities), letting an attacker discover the opponent's move before choosing their own.
    \item Anyone can call \texttt{open()}, meaning any account can reveal moves for players or manipulate when the game resolves.
    \item No deposit validation, so players can join without paying, and the contract incorrectly assumes it always holds exactly 1 ETH to pay the winner.
    \item \texttt{selfdestruct} sends all funds to the caller, allowing any user who triggers \texttt{open()} to steal the entire contract balance.
\end{itemize}


\section{Week 5}

\subsection{The Byzantine Generals Problem}

The Byzantine Generals Problem describes the difficulty of reaching agreement in a distributed system where some participants may behave arbitrarily or maliciously.

Key ideas:
\begin{itemize}
    \item Nodes may send conflicting or incorrect information.
    \item Honest parties cannot tell which messages are trustworthy.
    \item Reliable agreement requires a protocol that tolerates Byzantine faults.
\end{itemize}

This motivates the study of consensus protocols in adversarial environments.

\subsection{The Consensus Problem}

Consensus formalizes what it means for multiple parties to ``agree'' in a distributed setting.

A protocol must satisfy three properties:

\begin{itemize}
    \item \textbf{Termination}: every honest party eventually outputs a value.
    \item \textbf{Agreement}: all honest parties output the same value.
    \item \textbf{Validity}: if all honest parties start with the same input $v$, the output must be $v$.
\end{itemize}

\textbf{Strong validity} ensures that the output must originate from an honest party's input.

\subsection{Honest Majority Requirement}

There are fundamental impossibility results:

\begin{itemize}
    \item An adversary controlling too many parties can force violations of agreement or validity.
    \item In systems without trusted setup, consensus requires $t < n/3$ Byzantine faults.
    \item With cryptographic setup (e.g., PKI), consensus under synchrony is possible with $t < n/2$.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/consensus.png}
\end{figure}

Intuition: honest parties cannot distinguish among scenarios where different subsets of participants are corrupted; thus, too many adversarial parties break correctness.

\subsection{Classical vs Ledger Consensus}

Traditional consensus:
\begin{itemize}
    \item ``One-shot'' -- decides a single value.
    \item Uses authenticated channels and fixed participants.
    \item Ensures termination, agreement, validity.
\end{itemize}

Ledger (blockchain) consensus:
\begin{itemize}
    \item Runs indefinitely.
    \item Must incorporate new transactions continuously.
    \item Must tolerate dynamic participation and an unauthenticated, peer-to-peer network.
\end{itemize}

Ledger consensus replaces classical conditions with:
\begin{itemize}
    \item \textbf{Common Prefix} (consistency)
    \item \textbf{Chain Growth} (liveness)
    \item \textbf{Chain Quality} (adversarial influence bounded)
\end{itemize}

These properties define when a blockchain behaves like a consistent, append-only log.

\subsection{The Bitcoin Backbone Model}

Bitcoin is modeled as a protocol executed in synchronous rounds by many parties.

Core components:
\begin{itemize}
    \item \textbf{Chain validation predicate}: checks PoW correctness and structural validity.
    \item \textbf{Chain selection rule}: adopt the valid chain with the most cumulative work (``max-valid'' or longest chain rule).
    \item \textbf{Proof of Work function}: probabilistic mechanism enabling random leader election.
\end{itemize}

A block contains:
\begin{itemize}
    \item $\text{ctr}$: nonce for PoW.
    \item $x$: data such as transaction roots.
    \item $s$: hash pointer to previous block.
\end{itemize}

Finding a valid block requires hashing until:
\[
H(\text{ctr} \Vert x \Vert s) < T
\]
where $T$ is the global difficulty target.

\subsection{Key Security Properties of Blockchains}

\subsubsection{Common Prefix (Consistency)}

Honest parties’ blockchains differ only in the most recent $k$ blocks.  
This ensures finalized blocks do not get reverted.

Attack example:
\begin{itemize}
    \item \textbf{Racing attack}: adversary tries to build a secret chain to overtake the honest chain.
\end{itemize}

\subsubsection{Chain Growth}

In any sufficiently long period, the honest chain grows by at least a linear number of blocks.

Attack example:
\begin{itemize}
    \item \textbf{Abstention attack}: adversary withholds blocks to slow the chain.
\end{itemize}

\subsubsection{Chain Quality}

In any window of blocks, the fraction of adversarial blocks is bounded.  
This prevents adversaries from dominating the chain even if they temporarily get lucky.

Attack example:
\begin{itemize}
    \item \textbf{Block withholding attack}: adversary tries to replace honest blocks whenever they find their own.
\end{itemize}

\subsection{From Blockchain Properties to Ledger Consensus}

\begin{itemize}
    \item \textbf{Consistency} of the ledger derives from the Common Prefix property.
    \item \textbf{Liveness} derives from the combination of Chain Growth and Chain Quality.
    \item Honest blocks eventually appear and become irreversible after $k$ confirmations.
\end{itemize}

Thus, the blockchain implements a robust form of asynchronous, permissionless consensus.

\subsection{Proof of Work and Mining}

PoW mining is essentially a randomized leader election mechanism.

Properties:
\begin{itemize}
    \item Parallelizable: miners increase success probability by adding more hash power.
    \item Easy verification: given the nonce, checking PoW is one hash computation.
    \item Hard to shortcut: success probability is proportional to computational power.
\end{itemize}

\subsection{Mining Pools}

Because PoW rewards are probabilistic, miners cooperate in pools:

\begin{itemize}
    \item Miners submit ``shares'' to prove contributed work.
    \item Pool distributes rewards proportionally to contributed hash power.
\end{itemize}

\subsection{Dynamic Availability and Difficulty Adjustment}

Bitcoin must operate despite fluctuating numbers of miners.

\begin{itemize}
    \item If total hash power increases, blocks appear too quickly.
    \item If hash power decreases, block production slows.
\end{itemize}

Bitcoin adjusts difficulty every 2016 blocks to keep block intervals stable.

Let $f$ be the probability that at least one honest miner finds a block in a round:
\begin{itemize}
    \item If $f$ is too small: chain grows too slowly → liveness suffers.
    \item If $f$ is too large: many forks occur → consistency suffers.
\end{itemize}

Difficulty adjustment keeps $f$ within a safe range.

\subsection{Difficulty Raising Attack}

If the difficulty adjustment mechanism were poorly designed, an adversary with minority hash power could:
\begin{itemize}
    \item create a private chain with artificially high difficulty,
    \item exploit increased variance to occasionally overtake the honest chain.
\end{itemize}

Bitcoin avoids this by bounding difficulty adjustment using the epoch threshold.

\subsection{Summary}

\begin{itemize}
    \item Consensus in adversarial networks requires dealing with Byzantine faults.
    \item Classical consensus properties map to blockchain properties: Common Prefix, Chain Growth, Chain Quality.
    \item Bitcoin's PoW, longest chain rule, and difficulty adjustment together implement a secure ledger.
    \item Attacks such as racing, withholding, and difficulty raising highlight why the assumptions and parameter choices matter.
\end{itemize}

\section{Week 6}

\subsection*{Permissionless Protocols and Dynamic Availability}

Many blockchain protocols, such as Bitcoin, operate in a \textbf{permissionless} setting:

\begin{itemize}
  \item Anyone can join or leave the network without prior authorization.
  \item Anyone can read the ledger and, after acquiring coins, submit transactions.
  \item Participation in block production is open to anyone with the relevant resource (e.g.\ hash power).
\end{itemize}

The system must tolerate \textbf{dynamic availability}:

\begin{itemize}
  \item Nodes can come online or go offline at any time.
  \item New nodes need to bootstrap from the existing chain (e.g.\ follow the longest valid chain).
  \item There is no prior knowledge of how many parties are online at any moment.
\end{itemize}

Classic BFT protocols do not handle this type of open, highly dynamic participation. :contentReference[oaicite:0]{index=0}

\subsection*{Bitcoin's Energy Problem and Motivation for PoS}

Bitcoin uses Proof-of-Work (PoW) to solve consensus in a permissionless setting, but at a high cost:

\begin{itemize}
  \item Massive energy consumption due to hash-based mining.
  \item Significant electronic waste from rapidly obsolete mining hardware.
  \item An arms race between honest miners and attackers, where both must constantly burn energy. 
\end{itemize}

Empirical studies show that the climate damages per unit of Bitcoin value can be very high (comparable to some heavy industries), motivating \textbf{more energy efficient} consensus mechanisms such as Proof-of-Stake (PoS). :contentReference[oaicite:1]{index=1}

\subsection*{Nakamoto Design Recap}

The Nakamoto-style design has three main components:

\begin{itemize}
  \item Blocks are linked in a chain via hash pointers.
  \item In case of forks, nodes adopt the chain with the most accumulated resource (e.g.\ most work).
  \item New blocks are produced by a randomized lottery that selects leaders.
\end{itemize}

In PoW, the probability of winning the lottery is proportional to hash power.  
In PoS, the idea is to make it proportional to \textbf{stake}, that is the amount of cryptocurrency controlled by a party. :contentReference[oaicite:2]{index=2}

\subsection*{Proof-of-Stake Basics}

In PoS systems:

\begin{itemize}
  \item \textbf{Stake} is the amount of tokens or coins controlled by a public key.
  \item The protocol selects block producers based on stake.
  \item Security requires that honest parties collectively control a majority of stake.
\end{itemize}

PoS is resource based but uses a \emph{digital} resource. This makes PoS energy efficient, since no physical work is required for the lottery. :contentReference[oaicite:3]{index=3}

\subsection*{Time Slots and Leader Election}

Many PoS protocols divide time into \textbf{slots}:

\begin{itemize}
  \item The slot length is chosen so that messages can propagate within one slot under the network assumptions.
  \item Ideally, one block is produced per slot.
  \item Parties use their local clock to determine the current slot and act accordingly.
\end{itemize}

Time slotting simplifies analyzing and designing leader election: in each slot, the protocol selects which stakeholders are eligible to create a block. :contentReference[oaicite:4]{index=4}

\subsection*{From PoW to PoS: Design Attempts}

We want to replace the PoW condition
\[
  H(x, s, ctr) < T
\]
with a PoS-based condition that selects leaders in proportion to stake, but without introducing new vulnerabilities.

\subsubsection*{Attempt 1: Hash with Stake-Dependent Threshold}

Require
\[
  H(x, s, vk_n) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item The right-hand side scales with the stake of node \(n\).
\end{itemize}

\textbf{Problem: Grinding Attack on \(x\)}  
The adversary can vary \(x\) (for example the transaction Merkle root) until the inequality holds, gaining unfair advantage.

\subsubsection*{Attempt 2: Remove the Dependence on Block Content}

Require
\[
  H(s, vk_n) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item Now the left-hand side no longer depends on \(x\).
\end{itemize}

\textbf{Problem: Content Malleability}  
Since transactions are not included in the hash, an attacker can change the block contents without affecting the PoS condition. This breaks ledger integrity.

\subsubsection*{Attempt 3: Bind to History with Signatures}

Keep the PoS condition similar, but add:

\begin{itemize}
  \item Use the signing key for \(vk_n\) to sign the block content and a hash of the whole history.
\end{itemize}

This prevents content malleability, because changing the history requires forging signatures.

\textbf{Problem: Posterior Corruption}  
The adversary can corrupt a leader after the fact and obtain their old signing keys, then re-sign a different history at no cost (costless simulation of the past).

\subsubsection*{Attempt 4: Key Evolving Signatures (KES)}

Introduce \textbf{Key Evolving Signatures}:

\begin{itemize}
  \item Each party periodically updates its signing key and deletes the old one.
  \item The public key is fixed but internally refers to an evolving sequence of secret keys.
  \item Old signatures remain verifiable, but old signing keys are supposed to be irretrievably erased.
\end{itemize}

This blocks posterior corruption, since even if a party is corrupted later, its previous signing keys should no longer exist.

\textbf{Problem: Adaptive Attacks}  
If the public verification key \(vk\) that will be eligible in some future slot is known in advance, an adversary can adaptively corrupt that party before it produces its block.

\subsubsection*{Attempt 5: Verifiable Random Functions (VRFs)}

Use a \textbf{VRF} in the PoS condition:

\[
  \text{VRF}(sk_n, s) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item Each party privately evaluates the VRF using its secret key.
  \item The VRF output is publicly verifiable using \(vk_n\).
  \item A party only reveals the VRF proof if it wins the slot.
\end{itemize}

This hides the leader schedule, mitigating adaptive corruptions.

\textbf{Problem: Stalling Hazard}  
If no party satisfies the inequality in a slot, no block is produced and the same inputs could be reused, potentially stalling progress.

\subsubsection*{Attempt 6: Adding Time to the VRF Input}

To prevent stalling, extend the input with a time dependent value (such as slot or timestamp):

\[
  \text{VRF}(sk_n, s \parallel ts) < T \cdot \text{stakeFactor}_n
\]

\begin{itemize}
  \item As time advances, the input changes, so the lottery is re-run with fresh randomness.
  \item Combined with KES and signatures, this forms the basis of modern PoS protocols such as Ouroboros. 
\end{itemize}

This sequence of attempts highlights subtle attack surfaces (grinding, content malleability, posterior corruption, adaptive corruption, stalling) and how PoS designs address them.

\subsection*{Dynamic Stake and Key Grinding}

In realistic systems, stake changes over time:

\begin{itemize}
  \item Tokens are transferred between accounts.
  \item New stakeholders appear and old ones may leave.
\end{itemize}

The stake distribution becomes dependent on the particular chain branch, since different branches can contain different transactions.

\textbf{Key Grinding Attack}:

\begin{itemize}
  \item Keys are generated locally and are cheap to create.
  \item An adversary can try many potential key pairs and keep those whose VRF outputs give favorable leadership schedules.
\end{itemize}

Mitigations include committing to keys before using them and deriving VRF inputs from shared randomness that is itself derived from past protocol outputs.

\subsection*{Long-Range Attacks}

A \textbf{long-range attack} exploits the fact that in PoS, creating blocks is cheap once the stake is in adversarial hands:

\begin{itemize}
  \item Starting from an old block, the adversary constructs a private fork consisting only of adversarial blocks.
  \item On that fork, the adversary accumulates all block rewards, so their stake gradually dominates.
  \item Since producing blocks has no physical cost, the adversary can simulate very long chains offline.
  \item A newly joining node that sees both the honest chain and the adversarial long fork may be fooled into adopting the wrong one.
\end{itemize}

Two main countermeasures:

\begin{itemize}
  \item \textbf{Checkpointing}: honest participants rely on external trusted checkpoints (for example, from software updates or social consensus).
  \item \textbf{Chain density}: use local density statistics to distinguish honest chains from long-range forks (for example as in Ouroboros Genesis, where the honest chain is denser shortly after forks). 
\end{itemize}

\subsection*{Permissioned Ledgers and PKI}

In a \textbf{permissioned} ledger:

\begin{itemize}
  \item Only authorized participants can produce blocks or submit transactions.
  \item The set of participants is often static and known from the genesis block.
\end{itemize}

A Public-Key Infrastructure (PKI) is used:

\begin{itemize}
  \item Certification authorities issue X.509 certificates binding public keys to identities.
  \item Nodes authenticate each other using certificates and establish secure channels (for example via TLS).
  \item Certificates can be revoked if keys are compromised or algorithms become insecure.
\end{itemize}

\subsection*{Centralized vs Distributed Permissioned Ledgers}

\textbf{Centralized permissioned ledger (PoA)}:

\begin{itemize}
  \item A single server maintains the log of transactions.
  \item Clients authenticate to the server to read or write.
  \item Correctness and liveness rely entirely on the honesty and availability of the server.
\end{itemize}

\textbf{Distributed permissioned ledger}:

\begin{itemize}
  \item Multiple servers maintain replicated copies of the log.
  \item All servers share a genesis block containing the authorized participants.
  \item Writers send their inputs to all servers.
  \item Servers run a consensus protocol to decide which inputs to append.
\end{itemize}

Access control for readers and writers can be enforced via certificates attached to the genesis block and subsequent updates. :contentReference[oaicite:12]{index=12}

\subsection*{Classical BFT Consensus vs Nakamoto Consensus}

\textbf{Classical BFT consensus}:

\begin{itemize}
  \item Typically permissioned and runs among a fixed set of nodes.
  \item Does not rely on resource assumptions such as majority hash power or stake.
  \item Communication complexity is high: all parties participate in each consensus instance.
\end{itemize}

\textbf{Nakamoto-style consensus}:

\begin{itemize}
  \item Typically permissionless.
  \item Relies on an assumption that honest nodes control a majority of some resource (hash power or stake).
  \item Communication complexity is low: only the current leader needs to broadcast its block.
\end{itemize}

\subsection*{Graded Broadcast and BFT-Ledger Construction}

A key tool in BFT protocols is \textbf{graded broadcast} (graded consensus):

\begin{itemize}
  \item There is one sender and several receivers.
  \item Each receiver outputs a pair \((M_i, G_i)\) where \(M_i\) is a message and \(G_i \in \{0,1,2\}\) is a grade.
\end{itemize}

Properties:

\begin{itemize}
  \item If the sender is honest, all honest receivers output the same message with grade 2.
  \item If some honest receiver outputs \((M, 2)\), then all honest receivers output \(M\) with grade in \(\{1,2\}\).
\end{itemize}

Graded broadcast can be implemented in three communication rounds using threshold counts of messages (at least \(2n/3\) or at least \(n/3\)), assuming fewer than \(n/3\) Byzantine faults.

By combining graded broadcast with a \textbf{binary consensus} protocol, one can build a BFT ledger where each phase appends a new block when all parties agree on the same message. :contentReference[oaicite:13]{index=13}

\subsection*{Byzantine Binary Consensus and EIG}

In \textbf{Byzantine binary consensus}, each party starts with a bit \(v_i \in \{0,1\}\) and must output a bit \(u_i\) such that:

\begin{itemize}
  \item Termination: all honest parties eventually output.
  \item Agreement: all honest parties output the same bit.
  \item Validity: if all honest parties start with the same bit \(v\), then they must output \(v\).
\end{itemize}

One generic solution uses the \textbf{Exponential Information Gathering} (EIG) algorithm:

\begin{itemize}
  \item In round 1, each party sends its input to all others.
  \item In each subsequent round, parties forward what they heard in the previous round.
  \item Each party builds a labeled tree of possible message chains and then uses majority rules bottom up to decide an output.
\end{itemize}

In the synchronous setting, EIG terminates in \(t+1\) rounds with up to \(t\) Byzantine faults, and achieves agreement and validity under appropriate bounds on \(n\) and \(t\). :contentReference[oaicite:14]{index=14}

\subsection*{Impossibility Results and Thresholds}

There are several classical impossibility results:

\begin{itemize}
  \item For synchronous systems, consensus is impossible if \(n < 3t + 1\).
  \item For asynchronous systems, deterministic consensus is impossible with even a single fault (FLP result).
  \item With cryptographic setup and signatures, some bounds can be relaxed, but there are still lower bounds on the number of rounds and required number of parties.
\end{itemize}

These results justify why Nakamoto-style protocols assume resource majority instead of attempting fully asynchronous BFT consensus. 

\subsection*{BFT-style PoS Protocols}

BFT-style PoS protocols (such as Algorand) combine PoS leader selection with BFT agreement:

\begin{itemize}
  \item In each slot, a committee of stakeholders is selected using a PoS lottery (often via VRFs).
  \item The committee runs a BFT protocol to agree on the next block.
  \item Blocks are finalized once the committee reaches agreement.
\end{itemize}

Security questions include:

\begin{itemize}
  \item How to derive secure randomness for committee selection.
  \item How to prevent grinding attacks on randomness.
  \item How to handle adaptive corruptions and long-range attacks.
\end{itemize}

\subsection*{Open Questions in Ledger Protocols}

The lecture closes with several open research questions:

\begin{itemize}
  \item How to achieve permissionless clock synchronization and ensure that parties agree on time slots.
  \item How to incentivize key erasure in KES based systems, and whether rational parties might keep old keys.
  \item Whether systems can self-heal after temporary periods in which the adversary controls a majority of the resource (stake or hash power).
\end{itemize}

These questions are central to the ongoing development of secure and robust PoS and ledger protocols. :contentReference[oaicite:16]{index=16}


\section{Week 7}

\subsection{Cryptocurrency Economics and Incentives}

This lecture introduces the economic foundations of blockchain protocols.
Traditional analyses assume participants are either \emph{honest} or \emph{malicious}.
Instead, real systems involve rational agents who maximize their own utility.

Key questions:
\begin{itemize}
  \item Why should participants follow the protocol?
  \item Are consensus properties (safety, liveness) emergent from incentives?
  \item How do rewards, fees, and protocol rules shape rational behavior?
\end{itemize}

\subsection{Mining Incentives in Bitcoin}

A miner's revenue consists of:
\begin{itemize}
  \item \textbf{Transaction fees}: 
  \[
    \text{fee} = \sum \text{inputs} - \sum \text{outputs}.
  \]
  \item \textbf{Block reward}: newly minted coins created in the coinbase transaction.
\end{itemize}

\textbf{Coinbase transaction}:
\begin{itemize}
  \item First transaction in every block.
  \item No inputs; miner freely sets \texttt{scriptSig}.
  \item Output value must not exceed block\-reward + total fees.
\end{itemize}

\subsubsection{Bitcoin monetary policy}

\begin{itemize}
  \item Initial reward: 50 BTC.
  \item Reward halves every 210{,}000 blocks.
  \item Supply approaches a cap of $\approx 21$ million BTC.
\end{itemize}

Early eras create a disproportionate fraction of all BTC, leading to highly concentrated wealth distribution.

\subsection{Mining Profitability and Hardware}

Bitcoin may be mined using:
\begin{itemize}
  \item CPUs
  \item GPUs
  \item ASICs (specialized hardware)
\end{itemize}

Due to difficulty and energy cost, most hardware today mines at a net loss.
Mining profitability depends on:
\begin{itemize}
  \item electricity price,
  \item hardware efficiency,
  \item block reward and fee market,
  \item network difficulty.
\end{itemize}

This motivates mining pools.

\subsection{Nash Equilibrium in Blockchain Protocols}

Each participant has a \textbf{utility function}:
\[
  f_i(x_1,\dots,x_n),
\]
mapping all parties' strategies to a real-valued reward.

\textbf{Nash equilibrium}: no party can increase utility by unilaterally deviating.

Two mining reward models:
\begin{itemize}
  \item \textbf{Absolute rewards}: total BTC earned.
  \item \textbf{Relative rewards}: fraction of total BTC earned.
\end{itemize}

\textbf{Bitcoin under absolute rewards}: honest mining is a Nash equilibrium.  
\textbf{Bitcoin under relative rewards}: not a Nash equilibrium — selfish mining yields higher expected utility.

\subsection{Selfish Mining Attack}

Selfish mining is a deviation strategy allowing a coalition of miners to increase their \emph{relative} share of block rewards.

Key steps:
\begin{enumerate}
  \item Miner finds a block but withholds it (keeps it private).
  \item If honest miners find competing blocks, attacker strategically releases withheld blocks.
  \item Honest miners adopt attacker blocks first if attacker controls message propagation.
\end{enumerate}

Effects:
\begin{itemize}
  \item Public chain grows slower.
  \item Attacker obtains $>\alpha$ fraction of rewards even with only $\alpha$ fraction of hash power.
  \item With difficulty adjustment, absolute rewards may also increase.
\end{itemize}

\subsection{Block Reward Zero Attack}

When block rewards become negligible, miners rely solely on transaction fees.

A deviation becomes profitable:
\begin{itemize}
  \item If two blocks compete at the same height,
  \item a rational miner may choose the block leaving \emph{more unclaimed fees} for the next block,
  \item thus incentivizing mining on low-fee forks.
\end{itemize}

This threatens long-term stability when block rewards fade.

\subsection{Bribery Attacks}

An attacker creates a fork and includes a special transaction $\tau_0$ that offers a bribe to miners who extend the attacker's block.

\begin{itemize}
  \item $\tau_0$ double-spends its input on the public chain.
  \item If attack fails, attacker loses nothing (the bribe is invalidated).
  \item If miners adopt the fork, attacker may succeed at rewriting history.
\end{itemize}

Shows that economic incentives can be manipulated to undermine security.

\subsection{Mining Pools and Pool Attacks}

Miners join pools to reduce variance in income.

\subsubsection{Pool mechanics}
\begin{itemize}
  \item Pool sets an internal (higher) target $T_{\text{pool}}$.
  \item Miners submit ``shares'' proving partial work.
  \item If a real block is found, rewards are split proportional to contributed shares.
\end{itemize}

\subsubsection{Block withholding attack}

Pool A infiltrates Pool B with hash power $\alpha'$:
\begin{itemize}
  \item Infiltrators submit shares but withhold valid blocks.
  \item Pool B's effective block rate decreases.
  \item Pool A gains a larger \emph{relative} share of total network rewards.
\end{itemize}

This attack demonstrates competitive pressure among pools.

\subsection{Utility in Real-World Markets}

Real utility differs from in-protocol cryptocurrency utility.

Factors:
\begin{itemize}
  \item Fiat-denominated costs (hardware, electricity).
  \item Exchange rate volatility BTC/USD.
  \item Transaction fees and liquidity.
  \item Market reaction to attacks.
\end{itemize}

Surprisingly:
\begin{itemize}
  \item Markets often fail to penalize attacks.
  \item E.g.\ Ethereum Classic suffered multiple 2020 double-spend attacks without severe price decline.
\end{itemize}

Thus “attack decreases price, so attackers won’t attack” is not a reliable security assumption.

\subsection{Will Miners Attack Their Own System?}

Game-theoretic conclusion:
\begin{itemize}
  \item If an attack is profitable in expected value \emph{inside the protocol},
  \item and the external market does not sufficiently reduce price,
  \item rational miners may attack even if they hold stake in the ecosystem.
\end{itemize}

This highlights the need for:
\begin{itemize}
  \item careful incentive engineering,
  \item protocol design robust against rational deviations,
  \item mechanisms that align long-term network health with miner profit.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Bitcoin rewards (fees + subsidy) define miner incentives.
  \item Under absolute rewards, honest mining is an equilibrium; under relative rewards, selfish mining breaks equilibrium.
  \item Bribery, fee-driven attacks, and pool attacks reveal deeper incentive vulnerabilities.
  \item Markets often fail to punish protocol-level attacks.
  \item Economic analysis is necessary to understand and secure blockchain protocols.
\end{itemize}


\section{Week 8}

\subsection{Anonymity, Pseudonymity and Privacy}

\subsubsection{Identity models}

\textbf{Eponymous systems}:
\begin{itemize}
  \item Actions are directly linked to real-world identities.
  \item Examples: Facebook (real-name policy), verified accounts with KYC, parliamentary voting records.
\end{itemize}

\textbf{Pseudonymous systems}:
\begin{itemize}
  \item Identities are represented by arbitrary tags or usernames.
  \item A single user may control many pseudonyms; one pseudonym may be shared.
  \item Examples: Reddit / X handles, email addresses, graffiti tags such as ``Banksy''.
  \item \textbf{Sybil attack}: a single operator creates many pseudonyms to appear as many distinct participants.
\end{itemize}

\textbf{Anonymous systems}:
\begin{itemize}
  \item Actions cannot be linked to any particular participant.
  \item Only the size of the \emph{anonymity set} (the group of indistinguishable users) is known.
  \item Examples: secret ballots in elections, Tor usage as seen by a website.
\end{itemize}

\subsubsection{Anonymity vs fungibility}

\begin{itemize}
  \item \textbf{Fungibility}: any unit of a currency is interchangeable with any other.
  \item In Bitcoin every satoshi has a visible history on chain, so coins can be tainted or blacklisted.
  \item Privacy weaknesses therefore also impact fungibility.
\end{itemize}

\subsection{Bitcoin Privacy and Transaction Graph Analysis}

\subsubsection{Address reuse and pseudonymity}

\begin{itemize}
  \item Users can create arbitrary many new addresses without on-chain cost.
  \item In principle this gives pseudonymity, but transaction graph analysis can cluster addresses.
\end{itemize}

\subsubsection{Transaction graph analysis}

\begin{itemize}
  \item Nodes: addresses or transactions; edges: flows of value.
  \item Common patterns:
  \begin{itemize}
    \item \textbf{Peeling chain}: large UTXO is repeatedly split, sending small amounts and a ``peel'' change output each time.
    \item \textbf{Star}: one address sends to many others in a hub-and-spoke pattern.
  \end{itemize}
  \item These patterns help chain-analytic companies link addresses to the same user.
\end{itemize}

\subsubsection{Indistinguishability examples}

\begin{itemize}
  \item If Alice receives 50 BTC twice, the on-chain view may or may not reveal whether payments go to one person or two different ones.
  \item In many realistic spending patterns, observers can assign higher probability to one ``world'' (e.g.\ Alice-only) than to another (Alice plus Charlie), breaking privacy.
\end{itemize}

\subsection{Centralized Mixing and CoinJoin}

\subsubsection{Centralized mix}

\begin{itemize}
  \item Users send coins to a \emph{trusted party} that returns coins to recipients in shuffled order.
  \item The anonymity set has size \(n\) (the number of participants), but:
  \begin{itemize}
    \item the mixer can steal funds or log all mappings,
    \item it becomes a single point of failure and a target for regulation or seizure.
  \end{itemize}
\end{itemize}

\subsubsection{CoinJoin idea}

\begin{itemize}
  \item Multiple users jointly create a single transaction that mixes their inputs and outputs.
  \item Example: Alice and Charlie each spend inputs to standardized outputs (e.g.\ 1 BTC each).
  \item After mixing, an external observer cannot tell which input funded which standardized output.
\end{itemize}

\subsubsection{Multiple-input CoinJoin protocol}

\begin{itemize}
  \item Parties: \(n\) participants and one temporary \emph{leader}.
  \item Setup:
  \begin{itemize}
    \item Each participant sends to the leader:
    \begin{itemize}
      \item their recipient address \(b_i\),
      \item their change address \(c_i\),
      \item the corresponding amounts.
    \end{itemize}
    \item Leader constructs a combined transaction from all inputs and outputs.
  \end{itemize}
  \item Signing:
  \begin{itemize}
    \item Leader broadcasts the unsigned multi-input transaction to all participants.
    \item Each participant checks it and sends their signature back.
    \item Once all signatures are collected, the leader broadcasts the final transaction.
  \end{itemize}
  \item Abort issues and questions:
  \begin{itemize}
    \item Any participant can abort and prevent publication (DoS).
    \item A malicious leader can correlate inputs and outputs and violate privacy.
    \item It is non-trivial to restart without the offending party while preserving privacy.
  \end{itemize}
\end{itemize}

\subsubsection{Passive vs active adversaries}

\begin{itemize}
  \item \textbf{Passive} adversary: only observes on-chain transactions, gains anonymity set of size \(n\) per CoinJoin.
  \item \textbf{Active} adversary: participates in protocol (e.g.\ as leader) and sees mappings between participants and addresses, breaking privacy.
\end{itemize}

\subsection{Mix-nets and CoinJoin}

\subsubsection{Mix-nets}

\begin{itemize}
  \item A mix-net is a sequence of ``mix'' servers that shuffle and re-encrypt messages.
  \item As long as at least one mix in the chain is honest, it is impossible to link input messages to outputs.
  \item Two main variants:
  \begin{itemize}
    \item \textbf{Decryption mix-nets}: messages are layered with multiple public-key encryptions, each mix strips one layer and shuffles.
    \item \textbf{Re-encryption mix-nets}: mixes probabilistically re-encrypt and shuffle.
  \end{itemize}
\end{itemize}

\subsubsection{Using mix-nets for CoinJoin}

\begin{itemize}
  \item All participants first publish their public keys; mappings from public keys to accounts are public.
  \item They feed their addresses and amounts through a decryption mix-net.
  \item The final mix (leader) receives a shuffled list of outputs and can assemble the CoinJoin transaction but cannot tell which participant contributed which.
  \item Participants then sign the transaction as usual.
\end{itemize}

\subsubsection{Limitations and Mimblewimble}

\begin{itemize}
  \item Even with CoinJoin, output balances remain visible on chain.
  \item Mimblewimble-style systems use \textbf{Pedersen commitments}:
  \begin{itemize}
    \item Commitments hide balances but are additively homomorphic.
    \item A transaction proves that sum of inputs minus outputs equals zero without revealing amounts.
  \end{itemize}
\end{itemize}

\subsection{Blind Signatures, E-cash and Fair Swaps}

\subsubsection{Blind signatures}

\begin{itemize}
  \item A user blinds a message \(m\), sends it to a signer who produces a signature on the blinded value.
  \item After unblinding, the user obtains a valid signature on \(m\) that cannot be linked back to the signing interaction.
  \item Properties:
  \begin{itemize}
    \item Signature verifies against \(m\) and public key \(vk\).
    \item Signer never sees the cleartext message.
    \item Signer cannot link later published \((m,\sigma)\) pairs to specific users.
  \end{itemize}
\end{itemize}

\subsubsection{Chaum's e-cash}

\begin{itemize}
  \item Bank issues e-coins by blind-signing structured coin tokens.
  \item User withdraws an e-coin, then later presents it to a shop.
  \item Shop checks with the bank that the coin has not been spent before and that the signature is valid.
  \item Gives strong payer anonymity, but the bank is a trusted central party.
\end{itemize}

\subsubsection{Applying e-cash to Bitcoin payments}

\begin{itemize}
  \item A trustee exchanges on-chain BTC for off-chain e-coins via blind signatures.
  \item Users spend e-coins to shops, which redeem them for BTC from the trustee.
  \item Anonymity holds only if the trustee behaves correctly and does not log linkages or disappear with funds.
\end{itemize}

\subsubsection{Fair swaps}

\begin{itemize}
  \item Goal: two parties exchange secrets or assets so that either both receive their output or none do.
  \item Purely network-based fair exchange is impossible under standard assumptions.
  \item Workarounds:
  \begin{itemize}
    \item \textbf{Optimistic fair exchange} with a trusted third party used only for dispute resolution.
    \item \textbf{Resource-based fair exchange}: parties exchange partial information, so aborting gives the other party an advantage.
    \item \textbf{Fair swaps with penalties}: use a smart contract that escrows deposits and penalizes aborting parties financially.
  \end{itemize}
\end{itemize}

\subsection{Group Signatures, Ring Signatures and Monero}

\subsubsection{Group signatures}

\begin{itemize}
  \item System has a group manager and an opening authority.
  \item Any registered member can sign on behalf of the group:
  \begin{itemize}
    \item Verifier is convinced that ``some group member'' signed.
    \item Opening authority can later reveal which one, if necessary.
  \end{itemize}
  \item Useful for accountable anonymity.
\end{itemize}

\subsubsection{Traceable signatures}

\begin{itemize}
  \item Allow tracing across multiple signatures from the same user.
  \item Provide linkability or revocation for misbehaving members while preserving anonymity in normal cases.
\end{itemize}

\subsubsection{Ring signatures}

\begin{itemize}
  \item Signer chooses an arbitrary set of public keys (ring).
  \item Produces a signature that proves ``one of these keys signed'' but not which.
  \item No group manager or central authority is required.
  \item Verifier only knows that the signer is a member of the chosen anonymity set.
\end{itemize}

\subsubsection{Monero / Cryptonote}

\begin{itemize}
  \item Uses \textbf{linkable ring signatures}:
  \begin{itemize}
    \item Each coin output is one member of a ring.
    \item A key image ensures that spending the same output twice is detectable and linkable.
  \end{itemize}
  \item \textbf{Stealth addresses}:
  \begin{itemize}
    \item Sender creates one-time addresses for the recipient, unlinkable on chain.
    \item Recipient scans chain with their private view key to detect payments.
  \end{itemize}
  \item Provides stronger default privacy than Bitcoin, but anonymity still depends on real-world threat models and how rings are constructed.
\end{itemize}

\subsubsection{Anonymity set relevance}

\begin{itemize}
  \item A large anonymity set is only useful if the adversary cannot shrink it using side information.
  \item Example: a student using Tor on a campus network might be the only Tor user at a given time, making deanonymization easier despite Tor's design.
\end{itemize}

\subsection{Commitments, Zerocash and ZK-SNARKs}

\subsubsection{Commitments over the UTXO set}

\begin{itemize}
  \item For each coin, create a commitment \(\psi = \text{Commit}(\rho,(v,sn))\):
  \begin{itemize}
    \item \(\rho\): randomness,
    \item \(v\): value,
    \item \(sn\): serial number.
  \end{itemize}
  \item \(\psi\) is recorded in the ledger; opening reveals \(v\) and \(sn\) while hiding them from observers.
  \item Spending a coin reveals \(sn\) and proves that some ledger commitment contains \((v,sn)\) without showing which.
\end{itemize}

\subsubsection{Merkle tree over commitments}

\begin{itemize}
  \item All commitments are stored in a Merkle tree.
  \item Spending proof shows:
  \begin{itemize}
    \item existence of a leaf \(\psi_i\) equal to \(\text{Commit}(\rho,(v,sn))\),
    \item membership via a Merkle inclusion proof.
  \end{itemize}
  \item Statement and witness sizes grow only logarithmically in the number of coins.
\end{itemize}

\subsubsection{ZK-SNARK definition}

\begin{itemize}
  \item A SNARK is a \textbf{succinct, non-interactive argument of knowledge} for statements of the form:
  \[
    \exists w: R(x,w) = 1
  \]
  where \(R\) is a polynomial-time relation.
  \item Properties:
  \begin{itemize}
    \item \textbf{Soundness}: cheating provers cannot convince verifier of false statements, except with negligible probability.
    \item \textbf{Zero-knowledge}: proof reveals no information about witness \(w\) beyond truth of the statement.
    \item \textbf{Succinctness}: proof size and verification time are independent of witness size and running time of \(R\).
  \end{itemize}
\end{itemize}

\subsubsection{Zerocash coins and pour operations}

\begin{itemize}
  \item Accounts have a key pair \((vk,sk)\).
  \item Coin structure includes:
  \begin{itemize}
    \item \(vk\): public key of owner,
    \item \(v\): value,
    \item random seeds \(\rho,s,s'\),
    \item derived serial number \(sn = \text{PRF}_{sk}(\rho)\),
    \item commitments \(k = \text{Commit}(s, vk \Vert \rho)\) and \(\psi = \text{Commit}(s', v \Vert k)\).
  \end{itemize}
  \item \textbf{Pour} operation:
  \begin{itemize}
    \item Consume one coin and create two new coins of values \(v_1,v_2\) with \(v_1+v_2=v\).
    \item Reveal serial number \(sn\) and prove in zero-knowledge that:
    \begin{itemize}
      \item some Merkle leaf corresponds to a valid coin with that \(sn\),
      \item the value is conserved,
      \item new coins are well formed.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Common Reference String (CRS)}

\begin{itemize}
  \item Many SNARK schemes require a shared setup string.
  \item Generated via trusted setup or secure multi-party computation.
  \item \textbf{Updateable reference strings} and alternative proof systems (e.g.\ Bulletproofs) reduce trust but often at higher computational cost.
\end{itemize}

\subsection{Network Security and the Bitcoin P2P Layer}

\subsubsection{Overlay networks and requirements}

\begin{itemize}
  \item Blockchain protocols run on overlay networks built on top of the Internet.
  \item Desired properties:
  \begin{itemize}
    \item Timely (synchronous) message delivery within known bounds.
    \item Reliable point-to-point channels.
    \item Reliable broadcast for blocks and transactions.
  \end{itemize}
\end{itemize}

\subsubsection{Bitcoin's P2P design}

\begin{itemize}
  \item Peers are identified by IP addresses and communicate over TCP.
  \item Nodes maintain a limited number of outbound and inbound connections.
  \item Public vs private networks:
  \begin{itemize}
    \item Public IP hosts reachable directly.
    \item Private IP hosts behind NAT use a router to reach the Internet.
  \end{itemize}
\end{itemize}

\subsubsection{Peer discovery and address tables}

\begin{itemize}
  \item New nodes contact DNS seeders to get initial lists of peer IPs.
  \item Nodes gossip addresses via \texttt{ADDR} messages.
  \item Each node maintains:
  \begin{itemize}
    \item a \texttt{new} table: addresses learned but not yet tried,
    \item a \texttt{tried} table: peers that have successfully connected.
  \end{itemize}
  \item Connection selection uses a bias based on the ratio \(\rho\) between tried and new addresses, and recency of timestamps.
\end{itemize}

\subsubsection{Eclipse attacks}

\begin{itemize}
  \item Goal: isolate a victim node so all its connections are controlled by the attacker.
  \item Steps:
  \begin{itemize}
    \item Attacker fills victim's \texttt{tried} table with adversarial IPs by repeatedly connecting.
    \item Attacker floods \texttt{new} table with unreachable ``trash'' IPs via unsolicited \texttt{ADDR} messages.
    \item When victim restarts, it reconnects mostly to adversarial addresses.
    \item Attacker also saturates incoming connection slots so honest nodes cannot connect.
  \end{itemize}
  \item Consequences:
  \begin{itemize}
    \item Victim's view of the blockchain is fully controlled and can be censored.
    \item Victim's blocks and transactions may never reach the honest network.
  \end{itemize}
\end{itemize}

\subsubsection{Mitigations}

\begin{itemize}
  \item Restrict unsolicited \texttt{ADDR} messages.
  \item Diversify peers across IP ranges and autonomous systems.
  \item Probe peers before evicting long-lived entries from the \texttt{tried} table.
\end{itemize}

\subsubsection{Information propagation and MITM}

\begin{itemize}
  \item Bitcoin uses an inventory-based protocol:
  \begin{itemize}
    \item Node announces object hashes via \texttt{inv}.
    \item Peers request full objects via \texttt{getdata}.
  \end{itemize}
  \item Connections have a timeout window (for example, 20 minutes) before being dropped.
  \item A man-in-the-middle that delays or modifies messages can significantly slow block propagation and harm security.
\end{itemize}

\subsection{Wallets, SPV and Key Management}

\subsubsection{Full node wallets}

\begin{itemize}
  \item Store the entire blockchain plus UTXO set.
  \item Verify all transactions and blocks independently.
  \item Provide strongest security and privacy but require large storage and bandwidth.
\end{itemize}

\subsubsection{Merkle trees and SPV}

\begin{itemize}
  \item Blocks store only the Merkle root of transactions in their header.
  \item This allows lightweight \textbf{Simple Payment Verification (SPV)} clients:
  \begin{itemize}
    \item Download only block headers, not full blocks.
    \item Rely on full nodes to provide relevant transactions plus Merkle proofs.
    \item Verify PoW chain and inclusion of their own transactions.
  \end{itemize}
\end{itemize}

\subsubsection{SPV protocol and security}

\begin{itemize}
  \item SPV wallet:
  \begin{itemize}
    \item connects to several full nodes,
    \item sends a Bloom filter encoding its addresses so servers can filter relevant transactions,
    \item verifies signatures, basic transaction validity and inclusion under the correct Merkle root.
  \end{itemize}
  \item Assumes an honest majority of hash power.
  \item Does not hold full UTXO set and does not see unrelated transactions.
  \item A malicious server can only mislead the wallet temporarily by building an invalid fork or hiding transactions.
\end{itemize}

\subsubsection{HD wallets and seeds}

\begin{itemize}
  \item Hierarchical Deterministic (HD) wallets derive many key pairs from one master private key (BIP-32).
  \item A short mnemonic seed encodes the master key and can recover the whole wallet.
  \item Seed should be backed up offline, usually on paper and optionally encrypted with a passphrase.
\end{itemize}

\subsubsection{Hot vs cold wallets}

\begin{itemize}
  \item \textbf{Hot wallet}:
  \begin{itemize}
    \item Private keys on an Internet-connected device.
    \item Convenient for everyday spending.
    \item Higher risk of theft via malware or compromises.
  \end{itemize}
  \item \textbf{Cold wallet}:
  \begin{itemize}
    \item Private keys stored offline.
    \item Safer against remote attacks, less convenient for frequent payments.
    \item Balance can still be monitored via public keys on an online device.
  \end{itemize}
\end{itemize}

\subsubsection{Paper, brain and hardware wallets}

\begin{itemize}
  \item \textbf{Paper wallet}:
  \begin{itemize}
    \item Private key printed on paper, possibly encrypted with a passphrase.
    \item Secure against online attacks, but vulnerable to physical loss or damage.
  \end{itemize}
  \item \textbf{Brain wallet}:
  \begin{itemize}
    \item Private key derived from a human-memorizable passphrase.
    \item Extremely unsafe in practice due to low-entropy passwords; many have been brute-forced.
  \end{itemize}
  \item \textbf{Hardware wallet}:
  \begin{itemize}
    \item Dedicated device (e.g.\ Trezor, Ledger) storing keys in secure hardware.
    \item Keys never leave the device; device signs transactions and returns them to the host computer.
    \item Provides strong security even if the host computer is compromised.
    \item Protected by PIN and backed up via a seed.
  \end{itemize}
\end{itemize}

\subsection{Overall Takeaways}

\begin{itemize}
  \item Blockchain privacy ranges from pseudonymous to anonymous, and depends heavily on protocol design and user behavior.
  \item Techniques such as CoinJoin, mix-nets, blind signatures, ring signatures and ZK-SNARK-based systems aim to enlarge and protect anonymity sets.
  \item Network-layer security, especially resistance to eclipse and MITM attacks, is critical for maintaining consensus and censorship resistance.
  \item Wallet design (full node vs SPV, hot vs cold, HD vs hardware) reflects trade-offs between usability, security and privacy.:contentReference[oaicite:0]{index=0}
\end{itemize}

\section{Week 9}

\subsection{Security-Critical Computations}

Many computations in adversarial environments must guarantee correctness, privacy, and robustness even when participants misbehave.

Three categories:
\begin{itemize}
    \item \textbf{Deterministic with public inputs}: correctness is publicly checkable (e.g.\ recomputation).
    \item \textbf{Probabilistic with public inputs}: requires coordination to avoid bias (e.g.\ coin flipping).
    \item \textbf{Private inputs}: requires Secure Multiparty Computation (MPC).
\end{itemize}


\subsection{Passive vs Active Adversaries}

\textbf{Passive adversary (semi-honest)}:
\begin{itemize}
    \item Follows protocol steps exactly.
    \item Tries to learn extra information from received messages.
\end{itemize}

\textbf{Active adversary (malicious)}:
\begin{itemize}
    \item May deviate arbitrarily.
    \item Sends malformed or inconsistent messages.
    \item May send different data to different parties.
    \item Can refuse to participate at critical moments (selective abort).
\end{itemize}

Most MPC protocols secure against passive adversaries \emph{completely fail} in the active setting.


\subsection{Coin Flipping and Selective Abort}

Goal: generate a shared random bit between two distrustful parties.

Passive-secure protocol:
\begin{enumerate}
    \item Alice commits to $x$.
    \item Bob sends $y$.
    \item Alice opens $x$.
    \item Output: $x \oplus y$.
\end{enumerate}

\textbf{Selective abort attack:}  
Alice learns the final bit $x \oplus y$ before Bob does.  
If she dislikes the outcome, she refuses to open the commitment.

Thus:
\begin{itemize}
    \item Alice learns the output.
    \item Bob learns nothing.
\end{itemize}

This violates \textbf{fairness}, showing:

\[
\textbf{Two-party fair coin flipping is impossible without extra assumptions.}
\]


\subsection{Secret Sharing}

\subsubsection{Additive sharing}

A bit $s$ is shared as:
\[
s = a \oplus b,
\]
where $a$ is uniform and $b = s \oplus a$.

Each share reveals nothing individually.

\subsubsection{Shamir secret sharing}

Let $p(x)$ be a degree-$t$ polynomial with $p(0) = s$.

\begin{itemize}
    \item Share to party $i$: $p(i)$.
    \item Any $t+1$ points reconstruct $p(0)$.
    \item Fewer than $t+1$ points reveal no information.
\end{itemize}


\subsection{Verifiable Secret Sharing (VSS)}

Passive schemes break under malicious behavior.  
\textbf{VSS ensures shares are consistent even if the dealer is malicious}.

Key tools:
\begin{itemize}
    \item \textbf{Commitments}: dealer commits to polynomial coefficients (binding and hiding).
    \item \textbf{Encrypted shares}: each $p(i)$ is encrypted under $pk_i$.
    \item \textbf{NIZK proofs}: public proofs that encrypted shares form a valid Shamir sharing.
\end{itemize}

During reconstruction:
\begin{itemize}
    \item Parties broadcast shares.
    \item Reject inconsistent or invalid shares.
    \item Honest majority reconstructs the correct secret despite malicious participants.
\end{itemize}

VSS is the foundation for \textbf{active-secure MPC}.


\subsection{Secure Multiparty Computation (MPC)}

Goal:
\[
y = f(x_1, \dots, x_n)
\]
such that correctness and privacy hold even against malicious parties.

\subsubsection{Computation on shared values}

\paragraph{Addition} is local:
\[
[a] + [b] = [a+b].
\]

\paragraph{Multiplication} uses Beaver triples:  
Shared values $(u,v,w)$ with $w = uv$ are preprocessed.  
Enables multiplication with only one communication round.

\subsubsection{Output reconstruction and fairness}

Reconstruction requires all parties to reveal shares.

\textbf{Fairness problem:}  
A malicious party can learn the output first and then abort, preventing others from learning it.

Thus \emph{MPC cannot guarantee fairness without additional assumptions}.


\subsection{Fairness and Its Impossibility}

A protocol is fair if:
\begin{itemize}
    \item either all honest parties receive output,
    \item or none do.
\end{itemize}

\textbf{Impossibility:}  
In two-party settings, fairness cannot be achieved without:
\begin{itemize}
    \item trusted third parties,
    \item financial penalties,
    \item time-locked mechanisms,
    \item or blockchain enforcement.
\end{itemize}


\subsection{Fair Swaps via Blockchains}

Blockchains provide:
\begin{itemize}
    \item immutable logs,
    \item time-locks,
    \item enforceable penalties.
\end{itemize}

Two transactions:
\begin{itemize}
    \item \textbf{Publish TX}: reveals data or share.
    \item \textbf{Refund TX}: time-locked; refunds deposit if publish does not occur.
\end{itemize}

Properties:
\begin{itemize}
    \item Rational players cannot gain by aborting.
    \item Aborting results in monetary loss.
    \item Fairness becomes enforceable without secrecy on chain.
\end{itemize}


\subsection{Fair MPC via Fair Swap}

\begin{enumerate}
    \item MPC produces additive or Shamir sharings of output $y$: each party holds $y_i$.
    \item Parties exchange shares via blockchain-enforced fair swaps.
\end{enumerate}

If a party aborts:
\begin{itemize}
    \item honest parties receive compensation,
    \item no adversary gains advantage.
\end{itemize}


\subsection{N-Party Ladder Fairness}

Generalization of fair swaps to $n$ parties.

Structure:
\begin{itemize}
    \item Party $P_i$ reveals a prefix $(w_1,\dots,w_i)$.
    \item Deposits scale with position: $iB$ for $P_i$.
    \item Time-locks are staggered to prevent profitable aborts.
\end{itemize}

If $P_k$ aborts:
\begin{itemize}
    \item parties $1,\dots,k-1$ recover compensation,
    \item harm is limited to a predictable range.
\end{itemize}

Ensures honest behavior is the dominant strategy.


\subsection{Publicly Verifiable Secret Sharing (PVSS)}

PVSS strengthens VSS:

\begin{itemize}
    \item Anyone (not only participants) can verify correctness of shares.
    \item Enables public randomness beacons and distributed key generation.
\end{itemize}

Mechanisms:
\begin{itemize}
    \item Encryption of shares.
    \item Public zero-knowledge proofs of correct sharing.
\end{itemize}


\subsection{Post-Quantum Security}

Quantum computers threaten classical cryptography.

\subsubsection{Shor's algorithm}

Breaks:
\begin{itemize}
    \item RSA,
    \item Diffie-Hellman,
    \item Elliptic-curve signatures (ECDSA, Schnorr).
\end{itemize}

\subsubsection{Grover's algorithm}

Quadratic speedup for brute force.  
Security level of $n$-bit symmetric keys drops to $n/2$ bits.

Mitigation:
\begin{itemize}
    \item AES-256,
    \item doubling hash output lengths.
\end{itemize}


\subsection{Post-Quantum Cryptography (PQC)}

NIST-selected schemes:
\begin{itemize}
    \item \textbf{CRYSTALS-Kyber} (encryption/key exchange),
    \item \textbf{CRYSTALS-Dilithium} (signatures),
    \item \textbf{Falcon} (compact signatures),
    \item \textbf{SPHINCS+} (hash-based signatures).
\end{itemize}

Most rely on lattice problems:
\begin{itemize}
    \item Learning With Errors (LWE),
    \item Module-LWE,
    \item Shortest Vector Problem (SVP).
\end{itemize}


\subsection{Impact on Blockchains}

Quantum threats:
\begin{itemize}
    \item ECDSA signatures become forgeable.
    \item Public keys exposed on chain may be harvested today and broken later.
    \item Grover's algorithm affects PoW difficulty.
\end{itemize}

Mitigations:
\begin{itemize}
    \item Move to PQ signatures.
    \item Use hybrid classical--PQC schemes.
    \item Increase PoW hash output size.
\end{itemize}


\subsection{Quick Summary}

\begin{itemize}
    \item Passive-secure MPC fails under malicious behavior.
    \item Active adversaries require VSS and PVSS for correctness.
    \item Fairness is impossible without additional assumptions.
    \item Blockchains allow enforcing fairness via deposits and time-locks.
    \item Ladder fairness extends fair exchange to arbitrary $n$.
    \item Quantum computers break classical public-key crypto.
    \item PQC offers quantum-safe alternatives for future blockchains.
\end{itemize}

\section{Week 10}

\subsection{Finance and Financial Assets}

Finance concerns the creation, management, and investment of money and financial assets.

Financial assets are non-physical assets whose value derives from contractual claims, such as:
\begin{itemize}
    \item Bank deposits
    \item Stocks (equity securities)
    \item Bonds (debt securities)
    \item Loans
\end{itemize}

Financial services include lending, borrowing, issuing securities, and fund management.
Financial markets are marketplaces where such assets are traded.

\subsection{Decentralized Finance (DeFi)}

Decentralized Finance (DeFi) refers to financial products and services built on decentralized blockchain infrastructure.

Key characteristics:
\begin{itemize}
    \item No centralized intermediaries (banks, brokers, exchanges).
    \item Users retain direct control over their assets (non-custodial).
    \item Security depends on the underlying blockchain.
\end{itemize}

However, DeFi is exposed to new hazards due to the public and permissionless nature of blockchains.

\subsection{Securities and Regulation}

A security is a fungible, negotiable financial instrument with value, including:
\begin{itemize}
    \item Equity securities (stocks)
    \item Debt securities (bonds)
\end{itemize}

Under the U.S. Howey Test, a security involves:
\begin{itemize}
    \item Investment of money in a common enterprise.
    \item Expectation of profits derived from the efforts of others.
\end{itemize}

This distinction is critical when evaluating DeFi tokens, ICOs, and crowdfunding schemes.

\subsection{Exchanges and Decentralized Exchanges (DEXs)}

Exchanges facilitate trading between assets.
Centralized exchanges maintain custody and order books off-chain.

Decentralized Exchanges (DEXs):
\begin{itemize}
    \item Fully on-chain execution.
    \item Trades between native currency (e.g.\ ETH) and tokens (e.g.\ ERC20).
    \item Censorship-resistant but slower and more expensive due to blockchain fees.
    \item Typically lack KYC/AML.
\end{itemize}

\subsection{Automated Market Makers (AMMs)}

AMMs replace order books with liquidity pools.

For a trading pair A-B:
\begin{itemize}
    \item Reserves: $x$ units of A and $y$ units of B.
    \item Invariant: $x \cdot y = k$.
\end{itemize}

Swaps change the ratio of reserves, implicitly determining price.
Large trades cause slippage.

Liquidity providers are incentivized to keep pools large.

\subsection{DEX Attacks and MEV}

DEXs are vulnerable to transaction ordering attacks:
\begin{itemize}
    \item Front-running: attackers pay higher gas fees to execute before victims.
    \item Sandwich (insertion) attacks: attacker trades before and after a victim to extract profit.
\end{itemize}

Miners and validators can exploit transaction ordering (MEV).
Such attacks arise naturally from transparent mempools.

\subsection{Loans and Decentralized Lending}

Traditional loans involve risk assessment, interest, and potential default.

Decentralized loans rely on:
\begin{itemize}
    \item Price oracles for asset valuation.
    \item Over-collateralization.
    \item Automatic liquidation when collateral value drops.
\end{itemize}

Lenders deposit capital into smart-contract vaults; borrowers lock collateral.

\subsection{Flash Loans}

Flash loans are loans issued and repaid within a single atomic transaction.

Properties:
\begin{itemize}
    \item No default risk (transaction reverts if unpaid).
    \item Borrower can use large capital briefly.
\end{itemize}

They enable:
\begin{itemize}
    \item Arbitrage between DEXs.
    \item Oracle manipulation attacks.
    \item Wash trading and market manipulation.
\end{itemize}

\subsection{Market Capitalization}

Market capitalization is defined as:
\[
\text{Market Cap} = \text{circulating supply} \times \text{price}.
\]

Issues:
\begin{itemize}
    \item Price is determined by marginal trades on centralized exchanges.
    \item Market cap can be artificially inflated without new real-world money.
\end{itemize}

Key question:
\begin{itemize}
    \item How much real-world value actually backs crypto market capitalization?
\end{itemize}

\subsection{Stablecoins}

Stablecoins aim to maintain stable value (typically \$1).

\subsubsection{Fiat-backed Stablecoins}

Characteristics:
\begin{itemize}
    \item Centralized issuer.
    \item 1:1 promise with fiat held in escrow.
\end{itemize}

Risks:
\begin{itemize}
    \item Fractional reserves.
    \item Opaque auditing.
    \item Regulatory intervention.
\end{itemize}

Example: Tether (USDT), which poses systemic risk due to scale and opacity.

\subsubsection{Crypto-backed Stablecoins}

Mechanism:
\begin{itemize}
    \item Over-collateralization using crypto assets.
    \item Reliance on price oracles.
\end{itemize}

Problems:
\begin{itemize}
    \item Leverage amplifies price bubbles.
    \item Liquidation cascades cause death spirals.
\end{itemize}

Example: MakerDAO required centralized intervention during market crashes.

\subsubsection{Algorithmic Stablecoins}

Design:
\begin{itemize}
    \item No collateral.
    \item Supply adjusted algorithmically using bonds.
\end{itemize}

Failure reasons:
\begin{itemize}
    \item Depend on market confidence.
    \item Collapse when demand evaporates.
\end{itemize}

No major algorithmic stablecoin has survived long-term.

\subsection{Layer 2 Solutions}

Layer 1 blockchains scale poorly due to:
\begin{itemize}
    \item Limited throughput.
    \item High latency.
\end{itemize}

Layer 2 solutions:
\begin{itemize}
    \item Move most activity off-chain.
    \item Rely on Layer 1 for dispute resolution and final settlement.
\end{itemize}

Trade-off:
\begin{itemize}
    \item Improved scalability at the cost of modified trust assumptions.
\end{itemize}

\subsection{Digital Economy on a Blockchain}

Blockchains enable:
\begin{itemize}
    \item Recording monetary transactions transparently.
    \item Algorithmic creation of money.
\end{itemize}

Issues:
\begin{itemize}
    \item Tokens are often treated as speculative assets rather than currency.
    \item Valuation of on-chain economies is unclear.
\end{itemize}

\subsection{Blockchain Applications}

Across applications, blockchains excel at managing digital state but struggle with real-world integration.

Applications include:
\begin{itemize}
    \item Name registration.
    \item Land ownership.
    \item Local economies.
    \item Supply chain tracking.
    \item Philanthropy.
    \item Crowdfunding.
    \item Prediction markets.
    \item IoT micropayments.
    \item Gaming and NFTs.
\end{itemize}

Common limitation:
\begin{itemize}
    \item Oracles and off-chain trust reintroduce centralization.
\end{itemize}

\subsection{Key Takeaways}

\begin{itemize}
    \item DeFi removes intermediaries but introduces new attack surfaces.
    \item Market metrics such as capitalization can be misleading.
    \item Stablecoins pose systemic financial risks.
    \item Layer 2 improves scalability but weakens guarantees.
    \item Blockchain applications succeed best when assets are purely digital.
\end{itemize}



\end{document}
