\documentclass[10pt,a4paper,twocolumn]{article}

\usepackage[margin=1.4cm]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{float}
\usepackage{graphicx}

% Tighter section spacing and slightly smaller titles
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{3pt}{1pt}
\titleformat{\section}{\small\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\small\bfseries}{\thesubsection}{0.5em}{}

\setlength{\parskip}{2pt}
\setlength{\parindent}{0pt}
\setlist{noitemsep,topsep=1pt,leftmargin=*}

\date{}

\begin{document}
\small

\section{Week 1}

\subsection{Why Study Blockchains}

\textbf{High level idea:} Blockchains are a new paradigm for distributed secure systems.

They combine:
\begin{itemize}
  \item Cryptography (hashes, signatures, PoW).
  \item Distributed systems (consensus, P2P networks).
  \item Economics and game theory (incentives, equilibria).
\end{itemize}

Why they matter:
\begin{itemize}
  \item Help understand modern security mechanisms:
  \begin{itemize}
    \item Key management and PKI.
    \item Software integrity and update mechanisms.
    \item Privacy enhancing technologies.
  \end{itemize}
  \item Enable new organizational forms:
  \begin{itemize}
    \item Cryptocurrency and DeFi.
    \item DAOs, on chain governance.
    \item Token based coordination and funding.
  \end{itemize}
  \item Bitcoin is a concrete proof that a large scale open system can run for years without a central operator.
\end{itemize}

\subsection{Blockchains and Distributed Ledgers}

\subsubsection{Concepts}

\textbf{Blockchain:} a distributed, append only data structure that maintains a consistent log of transactions across many nodes.

\textbf{Distributed ledger:} a general term for systems that maintain shared state among multiple parties without a single trusted authority.

Desired properties:
\begin{itemize}
  \item \textbf{Safety:} all honest nodes agree on the same history (no conflicting logs).
  \item \textbf{Liveness:} valid transactions are eventually included and confirmed.
\end{itemize}

Bitcoin is the first widely deployed blockchain protocol that achieves these properties in a permissionless setting.

\subsection{Endless Ledger Parable}

\subsubsection{Book and Scribes}

Intuition: model Bitcoin as an endlessly growing ledger maintained by many \emph{scribes}.

\begin{itemize}
  \item There is a shared ledger (a book) with many numbered pages.
  \item Anyone can become a scribe and propose a new page.
  \item Each page records a batch of transactions.
  \item The ledger never stops growing: new pages are added over time.
\end{itemize}

Constraint: adding a page requires expensive work.

\begin{itemize}
  \item To write page \(i\), the scribe must solve a hard puzzle, like throwing many dice until a rare pattern appears.
  \item This represents Proof of Work (PoW).
\end{itemize}

\subsubsection{Forks and Longest Chain Rule}

Multiple copies of the ledger may exist:

\begin{itemize}
  \item Different scribes work in parallel and may produce conflicting next pages.
  \item Question: which ledger is the ``correct'' one?
\end{itemize}

\textbf{Rule:} everyone follows the ledger with the largest number of valid pages.

\begin{itemize}
  \item If several ledgers have the same maximum length, pick the first one you received and keep writing on top of it.
  \item Pages not on the longest ledger become \emph{orphan} pages.
\end{itemize}

This is the \textbf{longest chain rule}: choose the chain with the greatest cumulative work.

\subsubsection{Randomness and Symmetry Breaking}

Each page is produced by a random process (dice throwing, PoW search):

\begin{itemize}
  \item With many scribes, the chances that two of them keep finding pages in perfect lockstep are tiny.
  \item Eventually one scribe gets ahead, creating a longer ledger.
  \item Other scribes then switch to this longer ledger.
\end{itemize}

Randomness breaks symmetry and lets the system converge on a single chain.

\subsubsection{Incentives for Scribes}

To motivate scribes to do the costly work:

\begin{itemize}
  \item The rules allow the scribe who creates a valid new page to insert a special record awarding them a reward.
  \item In Bitcoin this is the block reward (newly minted coins) plus transaction fees.
\end{itemize}

Key points:
\begin{itemize}
  \item Anyone with computing resources can become a miner.
  \item More computing power implies higher probability of winning the next block.
\end{itemize}

\subsection{Scalable Service Provision Problem}

General IT question:

\textbf{How can we scale an online service to the whole world when participants do not trust each other and there is no central authority?}

Traditional answers:
\begin{itemize}
  \item \textbf{Federation:} multiple providers cooperate (e.g. email, XMPP).
  \item \textbf{Centralization:} one dominant provider (e.g. large social networks, cloud services).
\end{itemize}

Blockchains show a third option: decentralized provision by \emph{resource owners} instead of fixed organizations.

\subsubsection{Software Only Launch (SOL)}

Goal: deploy a system purely by publishing software.

\begin{itemize}
  \item Release an open source program.
  \item Announce a start time.
  \item Anyone can download the program and run it.
  \item When enough nodes run the software, the system ``self boots'' and becomes operational.
\end{itemize}

Bitcoin is a successful example of such a software only launch.

\subsection{Hash Functions}

\subsubsection{Definition and Basic Properties}

A hash function \(H\) maps inputs of arbitrary length to fixed length outputs.

Requirements:
\begin{itemize}
  \item Efficient to compute.
  \item Output looks random and is well spread over the output space.
\end{itemize}

Cryptographic security properties:
\begin{itemize}
  \item \textbf{Pre image resistance:} given \(y\), it is hard to find any \(x\) with \(H(x) = y\).
  \item \textbf{Second pre image resistance:} given \(x\), it is hard to find \(x' \neq x\) with \(H(x') = H(x)\).
  \item \textbf{Collision resistance:} it is hard to find any pair \(x \neq x'\) such that \(H(x) = H(x')\).
\end{itemize}

\subsubsection{Birthday Paradox}

If there are \(n\) possible hash outputs, collisions appear surprisingly early.

\begin{itemize}
  \item Approximate number of random samples needed for a collision with probability \(\approx 50\%\): \(k \approx 1.177 \sqrt{n}\).
  \item For hash outputs of \(t\) bits, \(n = 2^t\), so attacks based on collisions cost about \(2^{t/2}\) operations.
\end{itemize}

\subsubsection{Examples}

\begin{itemize}
  \item Broken: MD5, SHA 1 (known collisions).
  \item Current families: SHA 2 and SHA 3 with 224, 256, 384, 512 bit outputs.
  \item Bitcoin uses SHA 256 (from SHA 2 family).
\end{itemize}

\subsection{Digital Signatures}

\subsubsection{API}

A signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\):

\begin{itemize}
  \item \textbf{KeyGen}:
  \[
    (sk, vk) \leftarrow \text{KeyGen}(1^\lambda)
  \]
  where \(sk\) is the secret signing key, \(vk\) is the public verification key.
  \item \textbf{Sign}:
  \[
    \sigma \leftarrow \text{Sign}(sk, m)
  \]
  where \(m\) is the message.
  \item \textbf{Verify}:
  \[
    b \leftarrow \text{Verify}(vk, m, \sigma) \in \{0,1\}
  \]
  output 1 (accept) or 0 (reject).
\end{itemize}

\subsubsection{Security Intuition}

Existential unforgeability under chosen message attack (EU CMA):

\begin{itemize}
  \item Attacker can obtain signatures on messages of their choice from a signing oracle.
  \item Even with this advantage, attacker should not be able to produce a valid signature on a new message that was never signed before.
\end{itemize}

\subsubsection{Constructions}

\begin{itemize}
  \item Based on RSA (integer factorization hard).
  \item Based on discrete logarithms (DSA).
  \item Elliptic curve variants (ECDSA, Schnorr).
\end{itemize}

Bitcoin uses ECDSA originally and later also supports Schnorr style signatures.

\subsection{Proof of Work (PoW)}

\subsubsection{Definition}

A PoW scheme allows a prover to demonstrate that a certain amount of computational work has been done.

Typical hash based PoW:

\[
  \text{Find } w \text{ such that } H(\text{data} \Vert w) \le T
\]
where \(T\) is a difficulty target.

\subsubsection{Simple Algorithm}

\begin{verbatim}
ctr = 0
while H(data || ctr) > T:
    ctr = ctr + 1
return ctr
\end{verbatim}

Properties:
\begin{itemize}
  \item \textbf{Fast verification:} given \(w\), one hash evaluation checks whether the condition holds.
  \item \textbf{No shortcuts:} for a well designed hash function, there is no significantly faster way than brute forcing different \(w\).
\end{itemize}

\subsubsection{Variants}

\begin{itemize}
  \item Standard Hashcash style PoW (used in Bitcoin).
  \item Memory hard PoW (e.g. scrypt, Equihash) to force large RAM usage.
  \item ASIC resistant PoW to reduce the advantage of specialized hardware.
\end{itemize}

\subsection{Resource Based Systems}

\subsubsection{Resource Types}

In resource based systems participation is tied to control of some scarce resource:

\begin{itemize}
  \item \textbf{Proof of Work (PoW):} computational power.
  \item \textbf{Proof of Stake (PoS):} ownership of currency or tokens.
  \item \textbf{Proof of Space / Capacity:} available storage.
  \item \textbf{Proof of Time / Identity:} trusted hardware or other timing assumptions.
\end{itemize}

The system is not pinned to a fixed set of identities. Instead, any entity that can show a valid proof of resource can participate in maintaining the ledger.

\subsubsection{PoW vs PoS}

\textbf{PoW:}
\begin{itemize}
  \item Pros: simple design, well studied, direct link between cost and security.
  \item Cons: high energy usage, hardware centralization (ASIC farms), environmental concerns.
\end{itemize}

\textbf{PoS:}
\begin{itemize}
  \item Pros: lower energy usage, security based on economic value at stake.
  \item Cons: subtle security issues (nothing at stake, long range attacks), more complex protocol design.
\end{itemize}

\subsection{Tokenomics}

\subsubsection{Basic Idea}

Tokenomics studies how to use tokens and rewards to align incentives of participants.

Typical cycle:
\begin{itemize}
  \item Users pay fees to use the service (transactions, smart contracts).
  \item The protocol distributes rewards to resource providers (miners, validators).
  \item Providers sell some of their tokens to cover costs and profit.
\end{itemize}

Goal: set parameters so that:
\begin{itemize}
  \item Providing honest service is economically attractive.
  \item Attacking or misbehaving is economically disfavored.
\end{itemize}

\subsection{Decentralized Service Provision}

To run a decentralized service in an open network, the protocol must handle:

\begin{itemize}
  \item \textbf{DoS resistance:} prevent abuse by spamming transactions or connections.
  \item \textbf{Consistency:} all honest participants eventually agree on the same state.
  \item \textbf{Liveness and censorship resistance:} valid transactions should not be permanently excluded.
  \item \textbf{Fairness of rewards:} contributions of resource providers should be measured and rewarded in a predictable way.
\end{itemize}

\subsubsection{Reward Sharing}

Rewards can be distributed:
\begin{itemize}
  \item Per block or per action (e.g. each mined block gets a fixed reward).
  \item Per epoch (e.g. aggregate rewards over a time window then share according to contribution).
\end{itemize}

Design challenge:
\begin{itemize}
  \item Ensure that rational, self interested participants collectively form a robust and secure system.
  \item Avoid centralization and cartel behavior where possible.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Blockchains provide a new way to build global services without central operators.
  \item The ``endless ledger'' parable explains how longest chain and randomness yield consensus.
  \item Hash functions and digital signatures are the basic cryptographic tools for integrity and authenticity.
  \item Proof of Work ties block production to computational effort and is easy to verify.
  \item Resource based systems use PoW, PoS, or other proofs to select and reward maintainers.
  \item Tokenomics and reward sharing mechanisms align incentives so that honest behavior is profitable.
\end{itemize}

\section{Week2}
\subsection{Authenticated File Storage}

\textbf{Goal:} Store a file on an untrusted server but keep only a short local state 
so that later you can check whether the server returned the correct data.

Client has identifier \(F\) and data \(D\). It sends \((F,D)\) to the server, 
and wants to delete \(D\) locally while still being able to verify any future response from the server.

\subsubsection{Naive solution (does not help)}

Client keeps a full local copy of \(D\) and checks equality with any \(D'\) returned by the server. 
This gives integrity but saves no storage.

\subsection{Basic Cryptographic Tools}

\subsubsection{Hash-based authentication}

Hash function \(H\) is collision resistant.

\begin{itemize}
  \item Upload: client sends \((F,D)\) to server.
  \item Commit: client stores only \(h = H(D)\), deletes \(D\).
  \item Retrieval: server returns \(D'\).
  \item Verify: client accepts if \(H(D') = h\), rejects otherwise.
\end{itemize}

Properties:
\begin{itemize}
  \item Client keeps a short fixed-size value.
  \item Integrity relies on collision resistance of \(H\).
\end{itemize}

\subsubsection{Digital signatures}

Signature scheme \(\Sigma = (\text{KeyGen}, \text{Sign}, \text{Verify})\).

\begin{itemize}
  \item Key generation: client runs \(\text{KeyGen}\) to get \((sk, vk)\).
  \item Upload: compute \(\sigma = \text{Sign}(sk,\langle F,D\rangle)\), send \((F,D,\sigma)\) 
  to server.
  \item Client keeps only \(vk\).
  \item Retrieval: server returns \((D',\sigma')\).
  \item Verify: accept if \(\text{Verify}(vk,\langle F,D'\rangle,\sigma') = 1\).
\end{itemize}

Difference from pure hashing:
\begin{itemize}
  \item Signatures are publicly verifiable (third parties can check).
  \item Useful for transferable proofs of origin and integrity.
\end{itemize}

\subsection{Merkle Trees}

\subsubsection{Structure}

Goal: authenticate large data split into blocks, and allow efficient verification of 
individual blocks.

\begin{itemize}
  \item Split data \(D\) into blocks \(D_1,\dots,D_n\).
  \item Compute leaf hashes \(H_1 = H(D_1),\dots,H_n = H(D_n)\).
  \item Build a binary tree:
    \[
      H_{i,j} = H(H_i \Vert H_j)
    \]
    up to a single \emph{Merkle root} \(MTR\).
\end{itemize}

Client stores only \(MTR\) as the commitment to the entire file.

\subsubsection{Merkle-based storage protocol}

\begin{itemize}
  \item Upload: client sends full \(D\) to server, builds Merkle tree locally and 
  computes root \(MTR\), then keeps only \(MTR\).
  \item Retrieval of a block \(D_x\): server returns \(D_x\) and 
  a \emph{proof of inclusion} \(\pi\).
  \item Verification: client uses \(D_x\), \(\pi\), and \(H\) to recompute 
  a root and checks that it equals stored \(MTR\).
\end{itemize}

\subsubsection{Proof of inclusion}

For a block \(D_x\):
\begin{itemize}
  \item Proof consists of all sibling hashes along the path from the leaf \(H(D_x)\) to the root.
  \item Verifier:
    \begin{enumerate}
      \item Starts from \(H(D_x)\).
      \item Iteratively combines with sibling hashes and hashes upward.
      \item Checks whether the final value equals \(MTR\).
    \end{enumerate}
\end{itemize}

Tree height is \(O(\log n)\) for \(n\) leaves, so proof size and verification time are \(O(\log n)\).

\subsubsection{Applications}

\begin{itemize}
  \item BitTorrent: verify file chunks during download.
  \item Bitcoin: Merkle tree of transactions inside each block.
  \item Ethereum: variants of Merkle trees for state and transactions.
\end{itemize}

\subsection{Merkle Trees for Sets}

Goal: store a set \(S\) on a server and later prove membership or non-membership of any element \(x\).

Construction:
\begin{itemize}
  \item Sort the elements of \(S\).
  \item Build a Merkle tree where leaves are sorted elements.
\end{itemize}

\subsubsection{Membership proof}

If \(x \in S\), the server provides a normal proof of inclusion for the leaf corresponding to \(x\).

\subsubsection{Non-membership proof}

If \(x \notin S\):
\begin{itemize}
  \item Find neighbors \(H_{<}\) and \(H_{>}\) in the sorted order such that \(H_{<} < x < H_{>}\).
  \item Provide inclusion proofs for \(H_{<}\) and \(H_{>}\).
  \item Show they are adjacent in the sorted set representation.
  \item Conclude that \(x\) is not present.
\end{itemize}

\subsection{Tries and Patricia Tries}

\subsubsection{Trie (prefix tree)}

Data structure for a set of key-value pairs \(\{(key,value)\}\) where keys are strings.

\begin{itemize}
  \item Each edge is labeled with a character.
  \item A path from the root spells out a key.
  \item Nodes may store values for keys ending at that node.
\end{itemize}

Operations:
\begin{itemize}
  \item \textbf{add(key,value)}: follow or create edges for each character, 
  then store the value at the final node.
  \item \textbf{query(key)}: follow edges by characters, and check whether 
  the final node has a value.
\end{itemize}

\subsubsection{Patricia Trie}

Compressed version of a Trie:
\begin{itemize}
  \item Any chain of nodes where each node has a single child and no value 
  can be merged into a single edge labeled with a substring.
  \item Saves space and reduces tree height.
\end{itemize}

Patricia tries are widely used in blockchain systems for efficient key-value storage.

\subsection{Merkle Patricia Trie (MPT)}

Ethereum combines Merkle hashing with Patricia tries.

\subsubsection{Node types}

Keys are encoded in hexadecimal nibbles. There are three logical node types:


\begin{itemize}
  \item \textbf{Leaf node}: stores remaining key fragment and the value.
  \item \textbf{Extension node}: stores a shared key prefix and a pointer to another node.
  \item \textbf{Branch node}: has up to 16 child pointers (for hex digits) plus an optional value.
\end{itemize}

Each logical node is serialized and hashed. Child pointers store the hash of the child node, 
so the root hash commits to the entire key-value map.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_merkle_paricia_trie.png}
\end{figure}


\subsubsection{Properties}

\begin{itemize}
  \item Root hash acts as a commitment to the whole dictionary.
  \item Inclusion proofs: show the path from the root down to a leaf and the content of 
  intermediate nodes.
  \item Non-inclusion proofs: show that the search path terminates at a node that proves 
  no matching key exists.
  \item Ethereum uses an MPT for the global world state, and the state root hash is stored 
  in the block header.
\end{itemize}

\subsection{Blockchain Data Structures}

\subsubsection{Block structure}

A block consists of:
\begin{itemize}
  \item Random nonce \(\text{ctr}\).
  \item Data \(x\) (e.g. transactions, root hashes).
  \item Pointer \(s\) to the previous block (usually a hash of the previous header).
\end{itemize}

The header typically includes \((\text{ctr}, x, s)\). The pointer field \(s\) creates a hash 
chain of blocks back to the genesis block.

\subsubsection{Proof of Work (PoW)}

In PoW systems a block header must satisfy:
\[
  H(\text{ctr} \Vert x \Vert s) \le T
\]
where \(T\) is a global difficulty target.

\begin{itemize}
  \item Miners fix \(x\) and \(s\), iterate over \(\text{ctr}\), and search for a header whose 
  hash is below \(T\).
  \item The same hash is also used as the block identifier.
\end{itemize}

\subsection{Bitcoin Overview}

\subsubsection{High-level protocol}

\begin{enumerate}
  \item New transactions are broadcast to the network.
  \item Nodes collect transactions into candidate blocks.
  \item Nodes perform PoW to find valid blocks.
  \item A node that finds a valid block broadcasts it.
  \item Other nodes validate all transactions and the PoW before accepting.
  \item Nodes start mining on top of the longest valid chain.
\end{enumerate}

\subsubsection{UTXO model}

Bitcoin represents ownership via unspent transaction outputs (UTXOs).

\begin{itemize}
  \item A transaction has multiple inputs and outputs.
  \item Each \textbf{input} references a previous output (by transaction hash and index) and 
  provides a script that authorizes spending.
  \item Each \textbf{output} specifies a value and a script defining how it may be spent in the future.
\end{itemize}

\subsubsection{Scripts}

Typical pay-to-public-key-hash (P2PKH) transaction:

\begin{itemize}
  \item Output script (\texttt{scriptPubKey}): 
  \begin{align*}
    \text{OP\_DUP}\ \text{OP\_HASH160}\ \langle \text{pubKeyHash} \rangle \\
    \text{OP\_EQUALVERIFY}\ \text{OP\_CHECKSIG}
  \end{align*}
  
  \item Input script (\texttt{scriptSig}) when spent: 
  \[
    \langle sig \rangle\ \langle pubKey \rangle
  \]
\end{itemize}

During validation, the combined script is executed to check that the spender owns the 
corresponding private key.

\subsubsection{Merkle tree of transactions in a block}

\begin{itemize}
  \item All transactions in a block are organized as a Merkle tree.
  \item The Merkle root is stored in the block header.
  \item Simplified payment verification (SPV) clients download only block headers and 
  proofs of inclusion for specific transactions.
\end{itemize}

\subsection{Bitcoin Network}

\subsubsection{P2P topology}

\begin{itemize}
  \item All nodes run the same open-source protocol.
  \item Each node maintains connections to a set of peers.
  \item The network is permissionless: nodes may join or leave at any time.
\end{itemize}

Bootstrapping:
\begin{itemize}
  \item Peer-to-peer nodes come “pre-installed” with some peers by IP / host.
  \item A user can also manually configure known peers.
\end{itemize}

\subsubsection{Gossip protocol}

\begin{itemize}
  \item When a node learns about a new transaction or block, it forwards it to its peers.
  \item Each peer that sees a new item forwards it to its own peers.
  \item Nodes ignore items they have already seen.
  \item This peer-to-peer diffusion eventually spreads data to most honest nodes.
\end{itemize}

\subsubsection{Eclipse attacks and connectivity assumption}

\textbf{Connectivity assumption}: every honest node can reach every other honest node 
through some path in the network.

\textbf{Eclipse attack}:
\begin{itemize}
  \item Attacker surrounds a victim with malicious peers.
  \item Victim only connects to attacker-controlled nodes and is cut off from the honest network.
  \item This can delay or hide blocks and transactions, enabling double spending or 
  inconsistent views.
\end{itemize}

Maintaining good connectivity and diverse peer sets is critical for blockchain security.

\subsection{Quick Summary}

\begin{itemize}
  \item Hashes and signatures support basic authenticated storage.
  \item Merkle trees give efficient proofs of inclusion with size \(O(\log n)\).
  \item Merkle trees extend to sets and enable non-membership proofs.
  \item Tries store key-value maps by sharing prefixes; Patricia tries compress long paths.
  \item Merkle Patricia tries combine hashing and compressed tries; Ethereum uses them for state.
  \item Blockchain data structures link blocks using hash pointers and PoW.
  \item Bitcoin uses UTXOs, scripts, Merkle trees of transactions, and a P2P gossip network.
\end{itemize}

\section{Week 3}

\subsection{Smart Contracts: Concept}

\textbf{Smart contract:} a computer program that runs on the blockchain.

\begin{itemize}
  \item Code is stored on chain and executed by all full nodes.
  \item Execution is deterministic: all honest nodes get the same outcome.
  \item Code can read:
  \begin{itemize}
    \item Its own internal storage.
    \item Transaction context (sender, value, data).
    \item Recent block data (in Ethereum).
  \end{itemize}
  \item Code of a deployed contract cannot change (immutability).
\end{itemize}

Legal caution: from a legal point of view, ``smart contracts'' are usually neither legally smart nor contracts; they are programs enforcing some rules on chain.

\subsection{Bitcoin Transactions and Script}

\subsubsection{Transaction structure}

A Bitcoin transaction consists of:

\begin{itemize}
  \item \textbf{Inputs}:
  \begin{itemize}
    \item Reference to a previous transaction output (tx hash + index).
    \item \texttt{scriptSig}: unlocking script that proves right to spend.
  \end{itemize}
  \item \textbf{Outputs}:
  \begin{itemize}
    \item \texttt{value}: amount of BTC.
    \item \texttt{scriptPubKey}: locking script specifying spending conditions.
  \end{itemize}
\end{itemize}

Validation rule: for each input, the node executes
\[
\texttt{scriptSig} \Vert \texttt{scriptPubKey}
\]
on a stack machine and checks that it finishes with value \texttt{TRUE} on top of the stack.

\subsubsection{Bitcoin Script basics}

\begin{itemize}
  \item Stack based, not Turing complete.
  \item Data (e.g. \texttt{<sig>}, \texttt{<pubKey>}) is pushed to the stack.
  \item \textbf{Opcodes}:
  \begin{itemize}
    \item Arithmetic: \texttt{OP\_ADD}, \texttt{OP\_ABS}, \dots
    \item Stack operations: \texttt{OP\_DROP}, \texttt{OP\_SWAP}.
    \item Comparisons: \texttt{OP\_EQUAL}, \texttt{OP\_EQUALVERIFY}.
    \item Crypto: \texttt{OP\_HASH160}, \texttt{OP\_SHA256}.
    \item Signatures: \texttt{OP\_CHECKSIG}, \texttt{OP\_CHECKMULTISIG}.
    \item Timelocks: \texttt{OP\_CHECKLOCKTIMEVERIFY}, \texttt{OP\_CHECKSEQUENCEVERIFY}.
  \end{itemize}
\end{itemize}

\subsubsection{P2PKH example}

\textbf{Output script (\texttt{scriptPubKey}):}
\[
\texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
\]

\textbf{Input script (\texttt{scriptSig}) when spending:}
\[
\texttt{<sig> <pubKey>}
\]

Execution steps:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/btc_script_example.png}
\end{figure}

\subsection{Limitations of Bitcoin Script}

\begin{itemize}
  \item \textbf{No loops} and restricted control flow: not Turing complete.
  \item \textbf{No internal state}: script cannot store persistent variables.
  \item \textbf{Value blind}: script cannot inspect the exact amount being sent, it just validates spending conditions.
  \item \textbf{Blockchain blind}: cannot access block header fields (e.g. nonce, previous hash) except for basic locktime operations.
\end{itemize}

These limitations make Bitcoin simple and secure but restrict expressiveness.

\subsection{Extending Bitcoin Functionality}

Two main options:

\subsubsection{Build on top of Bitcoin}

\begin{itemize}
  \item Use Bitcoin as a base layer and encode extra logic at a higher protocol layer.
  \item Pros: reuses existing security and mining power; cheaper to deploy.
  \item Cons: limited flexibility because higher layer must respect Bitcoin's script and transaction model.
\end{itemize}

\subsubsection{Build an independent blockchain}

\begin{itemize}
  \item Design a new protocol from scratch (e.g. Ethereum).
  \item Pros: can add new opcodes and richer state; more expressive smart contracts.
  \item Cons: must bootstrap own validators or miners; higher development and maintenance cost.
\end{itemize}

\subsection{Ethereum Overview}

Ethereum keeps the blockchain idea but turns it into a \textbf{universal replicated state machine}.

\begin{itemize}
  \item One global state shared by all nodes.
  \item Transactions are state transition requests.
  \item A virtual machine (EVM) applies transactions to the state.
  \item Turing complete bytecode language for smart contracts.
  \item Decentralized applications (DApps) can be deployed and executed on chain.
\end{itemize}

Consensus and Sybil resistance:

\begin{itemize}
  \item Originally Proof of Work (Ethash), now Proof of Stake (validators, staking, Gasper).
\end{itemize}

\subsection{Ethereum Accounts}

\subsubsection{Global state}

Ethereum's global state is a mapping from 20-byte addresses to account objects.

Each account has:

\begin{itemize}
  \item \texttt{address}: 160-bit identifier.
  \item \texttt{balance}: amount of Ether (in wei).
  \item \texttt{nonce}: number of sent transactions.
  \item (for contract accounts) \texttt{code} and \texttt{storage}.
\end{itemize}

\subsubsection{Two types of accounts}

\textbf{Externally Owned Account (EOA):}

\begin{itemize}
  \item Address is derived from a public key: \(\text{addr} = H(\text{pubKey})\).
  \item Controlled by a private key held by a user.
  \item No code or storage.
\end{itemize}

\textbf{Contract account:}

\begin{itemize}
  \item Address is derived from creator address and nonce.
  \item Contains immutable contract code and persistent storage.
  \item Cannot initiate transactions on its own; reacts to incoming transactions or messages.
\end{itemize}

\subsubsection{UTxO vs account model}

\begin{itemize}
  \item UTxO:
  \begin{itemize}
    \item Better for privacy and parallelism.
    \item Outputs are spent or unspent.
  \end{itemize}
  \item Account model (Ethereum):
  \begin{itemize}
    \item Conceptually simpler.
    \item More compact representation of balances and state.
  \end{itemize}
\end{itemize}

\subsection{Ethereum Transactions}

A transaction includes:

\begin{itemize}
  \item \texttt{from}: recovered from the signature (sender's address).
  \item \texttt{to}: recipient address (EOA or contract). If empty, this is a contract creation tx.
  \item \texttt{value}: amount of Ether in wei.
  \item \texttt{data}: payload. For contracts this encodes which function to call and its arguments. Empty for simple ETH transfers.
  \item \texttt{nonce}: counts how many transactions the sender has already sent, prevents replay.
  \item \texttt{gasLimit} (\texttt{startgas}): maximum gas units the sender is willing to use.
  \item \texttt{gasPrice}: price per gas unit (or fee parameters in newer fee model).
  \item \texttt{signature}: proves authorization by the sender.
\end{itemize}

\subsubsection{Types of transactions}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/eth_tx_types.png}
\end{figure}

\subsection{Ethereum Block Structure and Production}

\subsubsection{Block header format}

Each Ethereum block contains the list of transactions and a commitment to the most recent global state.

The block header stores:

\begin{itemize}
  \item \textbf{prev}: hash pointer to the previous block.
  \item \textbf{hash}: block hash (identifier).
  \item \textbf{time}: block timestamp.
  \item \textbf{gasLimit}: maximum total gas allowed in the block.
  \item \textbf{gasUsed}: total gas consumed by included transactions.
  \item \textbf{nonce}: used in the old PoW design (no longer relevant under PoS).
  \item \textbf{difficulty}: PoW difficulty (historical field).
  \item \textbf{miner}: address of the block proposer (validator under PoS).
  \item \textbf{extra}: optional metadata.
  \item \textbf{state root}: Merkle Patricia Trie root of the global account state.
  \item \textbf{transaction root}: Merkle root of all transactions in this block.
  \item \textbf{receipt root}: Merkle root of all transaction receipts (status, logs, gas usage).
\end{itemize}

The \textbf{state root} commits to all accounts, where each account record contains:
\begin{itemize}
  \item \textbf{address}
  \item \textbf{code} (empty for EOAs)
  \item \textbf{storage} (persistent key/value data)
  \item \textbf{balance} (in wei)
  \item \textbf{nonce} (number of sent transactions)
\end{itemize}

\subsubsection{Block production and rewards}

\begin{itemize}
  \item Blocks contain: the ordered transaction list and the most recent state (via the state root).
  \item Typical block time: about \textbf{12 seconds}.
  \item Since 2022, Ethereum uses \textbf{Proof-of-Stake (Gasper)} for Sybil resistance and consensus.
  \item Previously, Ethereum used \textbf{Proof-of-Work} with Ethash (memory-hard PoW).
\end{itemize}

Rewards and fees:

\begin{itemize}
  \item \textbf{Before the Merge (PoW):} block miner received a fixed block reward (e.g.\ 2 ETH) plus all transaction fees.
  \item \textbf{After the Merge (PoS):}
  \begin{itemize}
    \item The block proposer (validator) receives a \textbf{base block reward} (newly issued ETH), depending on total ETH staked.
    \item Each transaction has a \textbf{base fee} which is \emph{burned}, reducing total ETH supply.
    \item Users can add \textbf{priority fees (tips)} that are paid directly to the block proposer.
  \end{itemize}
\end{itemize}


\subsection{Messages between contracts}

Contracts cannot create real transactions, but can send \emph{messages}:

\begin{itemize}
  \item Messages are internal calls generated by running contract code.
  \item They exist only inside EVM execution and are not part of the P2P network.
  \item A message can transfer ETH and call functions of other contracts.
\end{itemize}

Execution chain:

\begin{itemize}
  \item External transaction triggers code of a contract.
  \item That contract can send messages to other contracts.
  \item Each recipient runs its code in turn.
\end{itemize}

\subsection{Ethereum Virtual Machine (EVM)}

\begin{itemize}
  \item Stack based architecture with 1024-element stack of 256-bit words.
  \item Bytecode instruction set; each opcode has a defined gas cost.
  \item Three data areas:
  \begin{itemize}
    \item \textbf{Stack}: last-in first-out, used for intermediate values.
    \item \textbf{Memory}: transient byte array, cleared between transactions.
    \item \textbf{Storage}: persistent key-value store, written to and read by contract code.
  \end{itemize}
  \item Crypto primitives: hash functions, signature verification.
  \item Can read execution context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{block.timestamp}, etc.
\end{itemize}

\subsection{Gas and Transaction Fees}

\subsubsection{Why gas is needed}

\begin{itemize}
  \item Every node must execute all transactions and keep the full state.
  \item Without limits, a malicious contract could run forever (halting problem).
  \item Gas sets a hard bound on how much computation and storage a transaction may consume.
\end{itemize}

\subsubsection{Gas fields in a transaction}

\begin{itemize}
  \item \textbf{Gas limit} (\texttt{startgas}): maximum gas units the sender allows for this transaction.
  \item \textbf{Gas price}: price per gas unit in wei (or equivalent fee parameters).
\end{itemize}

Maximum fee the sender is willing to pay is:
\[
\text{maxFee} = \text{gasLimit} \times \text{gasPrice}.
\]

\subsubsection{Execution with gas}

Simplified algorithm for a transaction:

\begin{enumerate}
  \item Check that \(\text{gasLimit} \times \text{gasPrice} \le \text{balance}\). If not, reject.
  \item Deduct \(\text{gasLimit} \times \text{gasPrice}\) from sender balance.
  \item Set \texttt{gas} \(\leftarrow \text{gasLimit}\).
  \item Execute bytecode, decreasing \texttt{gas} by the cost of each operation.
  \item If execution finishes normally, refund unused gas:
  \[
  \text{refund} = \text{gasRemaining} \times \text{gasPrice}.
  \]
  \item If gas reaches zero before finishing (out of gas), revert state changes. The prepaid fee is not refunded.
\end{enumerate}

Note: blocks also have a \emph{block gas limit}, so the sum of gas used by all transactions in a block cannot exceed this bound.

\subsection{Introduction to Solidity}

Solidity is a high level language that compiles to EVM bytecode.

\begin{itemize}
  \item Syntax resembles JavaScript.
  \item Statically typed: every variable must have an explicit type.
  \item Supports contracts, state variables, functions, events, modifiers, inheritance, and interfaces.
\end{itemize}

\subsubsection{Basic contract example}

A minimal contract usually:

\begin{itemize}
  \item Starts with a \texttt{pragma} line specifying the compiler version range.
  \item Declares a \texttt{contract} with a name.
  \item Contains one or more functions. For example, a simple contract \texttt{HelloWorld} may have a \texttt{print} function marked \texttt{public} and \texttt{pure} that returns the string \texttt{"Hello World!"}.
\end{itemize}

\subsection{Solidity: Variables and Types}

\subsubsection{State vs local variables}

\begin{itemize}
  \item \textbf{State variables}:
  \begin{itemize}
    \item Declared at contract level.
    \item Stored in contract storage (persistent and expensive to change).
  \end{itemize}
  \item \textbf{Local variables}:
  \begin{itemize}
    \item Declared inside functions.
    \item Live only during function execution.
    \item Value types are kept on the stack; reference types require an explicit data location.
  \end{itemize}
\end{itemize}

\subsubsection{Value types}

\begin{itemize}
  \item \textbf{bool}: \texttt{true} or \texttt{false}.
  \item \textbf{int} and \textbf{uint}: signed and unsigned integers of 8 to 256 bits (e.g.\ \texttt{uint256}, \texttt{int8}).
  \item \textbf{address}: 20-byte address; \texttt{address payable} can receive Ether.
  \item \textbf{bytes1} to \textbf{bytes32}: fixed size byte arrays.
  \item \textbf{enum}: user defined type with a finite set of named values.
\end{itemize}

Variables without explicit initialization receive the default zero value for their type.

\subsubsection{Reference types}

\begin{itemize}
  \item Dynamic arrays: \texttt{uint[]} or \texttt{bytes} or \texttt{string}.
  \item Static arrays: for example, \texttt{uint[5]}.
  \item \textbf{mapping(KeyType => ValueType)}: key-value dictionary, non-iterable.
  \item \textbf{struct}: groups multiple fields into one type, e.g.\ a \texttt{Voter} struct with fields for weight, address, and whether they have voted.
\end{itemize}

\subsection{Visibility and Function Types}

\subsubsection{Visibility of functions and variables}

\begin{itemize}
  \item \textbf{public}:
  \begin{itemize}
    \item Functions callable from outside and inside contracts.
    \item For public state variables, the compiler generates a getter automatically.
  \end{itemize}
  \item \textbf{external}:
  \begin{itemize}
    \item Callable only from outside the contract.
    \item Cannot be used for state variables.
  \end{itemize}
  \item \textbf{internal}:
  \begin{itemize}
    \item Callable only inside the contract or from derived contracts.
  \end{itemize}
  \item \textbf{private}:
  \begin{itemize}
    \item Callable only inside the contract that defines them (not visible in children).
  \end{itemize}
\end{itemize}

\subsubsection{Function modifiers (state mutability)}

\begin{itemize}
  \item \textbf{view}: function promises not to modify state, but may read it.
  \item \textbf{pure}: function promises not to read or modify state (depends only on its arguments).
  \item \textbf{payable}: function can receive Ether along with the call.
\end{itemize}

Remember: on-chain data is publicly visible regardless of visibility keywords; these only restrict who can \emph{invoke} a function.

\subsection{Solidity Inheritance and Interfaces}

\begin{itemize}
  \item Solidity supports multiple inheritance between contracts.
  \item The keyword \texttt{is} is used to derive one contract from another.
  \item Derived contracts can access non-\texttt{private} state and internal functions of parents.
  \item Interfaces are abstract contracts that only declare function signatures (no implementation). Implementing contracts must provide the body of each function.
\end{itemize}

Typical pattern:

\begin{itemize}
  \item Define an interface \texttt{Regulator} that specifies functions like \texttt{checkValue} and \texttt{loan}.
  \item Implement a concrete \texttt{Bank} contract \texttt{is Regulator} that maintains an internal balance, implements deposit/withdraw functions, and provides concrete definitions of \texttt{checkValue} and \texttt{loan}.
\end{itemize}

\subsection{Data Location: storage, memory, calldata}

\begin{itemize}
  \item \textbf{storage}:
  \begin{itemize}
    \item Persistent key-value store for state variables.
    \item Expensive to read and write; changes are stored on chain.
  \end{itemize}
  \item \textbf{memory}:
  \begin{itemize}
    \item Temporary area for reference types inside functions.
    \item Cleared after the function ends.
  \end{itemize}
  \item \textbf{calldata}:
  \begin{itemize}
    \item Read-only location for function arguments of external functions.
    \item Cheaper than memory for dynamic types.
  \end{itemize}
\end{itemize}

Assignment behaviour:

\begin{itemize}
  \item \texttt{storage} $\leftrightarrow$ \texttt{memory}: data is copied.
  \item \texttt{memory} $\leftrightarrow$ \texttt{memory}: references are passed.
  \item Local variables of type \texttt{storage} act as references (aliases) to existing state variables.
\end{itemize}

\subsection{Events and Modifiers}

\subsubsection{Events}

\begin{itemize}
  \item Provide a logging mechanism inside the EVM.
  \item Event arguments are stored in the transaction log, not in contract storage.
  \item Off-chain clients (e.g.\ in JavaScript or Python) can subscribe to events and react to them.
  \item A typical pattern is an event such as \texttt{Deposit(from, id, value)} emitted whenever Ether is deposited into the contract.
\end{itemize}

\subsubsection{Modifiers}

\begin{itemize}
  \item Modifiers are reusable preconditions or wrappers around functions.
  \item The body of the modifier is injected at the point where \texttt{\_;} appears.
  \item Common example: an \texttt{onlyOwner} modifier that checks \texttt{msg.sender == owner} before executing the function body.
  \item A contract \texttt{Owned} may set the \texttt{owner} to the deployer in the constructor and define \texttt{onlyOwner}; a derived contract \texttt{Mortal} can then protect a \texttt{close} function with this modifier.
\end{itemize}

\subsection{Global Variables and Units}

\subsubsection{Ether units}

\begin{itemize}
  \item \texttt{1 ether == 10\string^18 wei}.
  \item Other common units: \texttt{wei}, \texttt{gwei}, \texttt{szabo}, \texttt{finney}.
\end{itemize}

\subsubsection{Time units}

\begin{itemize}
  \item Suffixes: \texttt{seconds}, \texttt{minutes}, \texttt{hours}, \texttt{days}, \texttt{weeks}.
  \item Example: \texttt{1 hours == 60 minutes}.
\end{itemize}

\subsubsection{Common global variables}

\begin{itemize}
  \item Block properties: \texttt{block.timestamp}, \texttt{block.number}, \texttt{block.coinbase}.
  \item Transaction and message context: \texttt{msg.sender}, \texttt{msg.value}, \texttt{msg.data}, \texttt{tx.origin}.
  \item Address helpers: \texttt{addr.balance}, \texttt{addr.transfer(...)}, \texttt{addr.call(...)}.
\end{itemize}

\subsection{Fallback and Receive Functions}

\begin{itemize}
  \item \texttt{receive()}:
  \begin{itemize}
    \item Declared as \texttt{receive() external payable}.
    \item Executed when the contract receives Ether with empty data.
  \end{itemize}
  \item \texttt{fallback()}:
  \begin{itemize}
    \item Declared as \texttt{fallback() external} (optionally \texttt{payable}).
    \item Executed when no other function matches the call data, or when data is non-empty and \texttt{receive} does not exist.
  \end{itemize}
  \item Both functions should be simple and use little gas to avoid unexpected failures.
\end{itemize}

\subsection{Sending Ether: transfer, send, call}

\begin{itemize}
  \item \texttt{transfer}:
  \begin{itemize}
    \item Forwards 2300 gas to the recipient.
    \item Reverts on failure.
    \item Historically considered safe against re-entrancy because the gas stipend is small.
  \end{itemize}
  \item \texttt{send}:
  \begin{itemize}
    \item Also forwards 2300 gas.
    \item Returns a boolean success flag instead of reverting; caller must check it.
  \end{itemize}
  \item Low-level \texttt{call} with value:
  \begin{itemize}
    \item Can send Ether and forward an arbitrary amount of gas.
    \item Returns a success flag and returned data.
    \item Flexible but vulnerable to re-entrancy if state updates and external calls are not ordered carefully.
  \end{itemize}
\end{itemize}

Best practice: use \texttt{call} together with the checks--effects--interactions pattern and, if needed, explicit re-entrancy guards.

\subsection{Interacting with Other Contracts}

\begin{itemize}
  \item Contracts can create new contracts and call existing ones.
  \item A typical pattern: a ``factory'' contract that deploys new instances of another contract (e.g.\ \texttt{Universe} creating many \texttt{Planet} contracts), stores their addresses in an array, and emits an event each time a new instance is created.
  \item Interaction is done by using the other contract's type and calling its functions as methods.
\end{itemize}

\subsection{Quick Summary}

\begin{itemize}
  \item Bitcoin uses a stack based, non Turing complete scripting system to authorise spending of UTxOs.
  \item Ethereum generalises blockchains into a universal replicated state machine with accounts, contracts, and global state.
  \item The EVM is a stack machine with storage, memory, and stack; gas ensures that computation is bounded and paid for.
  \item Solidity is a high level language for writing contracts, with explicit types, visibility, data locations, and support for inheritance.
  \item Events, modifiers, and global variables are key tools for building practical contracts.
  \item Ether transfers use \texttt{transfer}, \texttt{send}, or \texttt{call}; understanding their differences is important for security.
\end{itemize}


\section{Week 4}

\subsection{1. Lecture Overview}
This lecture focuses on identifying security hazards in smart contracts and designing safer contract architectures. We examine four main attack vectors:
\begin{itemize}
    \item Denial-of-Service (DoS)
    \item Griefing attacks
    \item Reentrancy attacks
    \item Front-running
\end{itemize}

Key defensive patterns include Pull-over-Push, Checks--Effects--Interactions, safe fallback design, avoiding \texttt{tx.origin}, safe randomness, and overflow/underflow protection.

\subsection{2. Denial-of-Service and Griefing}

\textbf{Unbounded loops} can make functions impossible to execute once arrays grow large.
Example insecure pattern:
\begin{verbatim}
for (uint i=0; i<investors.length; i++) {
    investors[i].addr.send(investors[i].dividendAmount);
}
\end{verbatim}

As the array size increases, gas requirements exceed block limits, leading to DoS.  
Griefing attacks intentionally exploit this by causing certain \texttt{send()} calls to fail, blocking all refunds.

\textbf{Solution: Pull-over-Push}.  
Instead of transferring funds inside a loop, store refund balances and allow users to withdraw individually.
\begin{verbatim}
// Pull model
refunds[user] += amount;
function withdrawRefund() external {
    uint r = refunds[msg.sender];
    refunds[msg.sender] = 0;
    msg.sender.transfer(r);
}
\end{verbatim}

\subsection{3. Reentrancy Attacks}

A reentrancy attack occurs when an external call triggers a fallback function that re-enters the vulnerable contract before state updates occur.

\textbf{Vulnerable pattern:}
\begin{verbatim}
uint amount = balances[msg.sender];
require(msg.sender.call.value(amount)());
balances[msg.sender] = 0;
\end{verbatim}

Attackers repeatedly drain funds through recursive fallback calls.  
The DAO attack (2016) exploited this weakness, resulting in a \$50M loss.

\textbf{Mitigation: Checks--Effects--Interactions.}
\begin{verbatim}
uint amount = balances[msg.sender];
balances[msg.sender] = 0;
msg.sender.transfer(amount);
\end{verbatim}

Additional protections: mutex locks, Pull-over-Push pattern.

\subsection{4. Solidity-Specific Hazards}

\textbf{4.1 Forcibly sending Ether}.  
Ether can be sent to a contract without triggering fallback functions, e.g.:
\begin{itemize}
    \item \texttt{selfdestruct(target)}
    \item precomputed contract addresses
    \item block reward redirection
\end{itemize}
Thus, do not rely on strict balance equality.

\textbf{4.2 Delegatecall hazards}.  
\texttt{delegatecall} uses the caller's storage and \texttt{msg.sender}.  
Malicious libraries can overwrite critical variables like \texttt{owner}.

\textbf{4.3 Misuse of \texttt{tx.origin}}.  
Using \texttt{tx.origin} for authorization enables phishing attacks. Always use \texttt{msg.sender}.

\textbf{4.4 Fallback complexity}.  
Fallback functions should contain minimal logic to avoid vulnerabilities such as reentrancy.

\textbf{4.5 Default values}.  
Uninitialized mapping entries return default values (e.g., 0).  
Incorrect handling led to the Nomad Bridge hack (2022).

\subsection{5. Merkle Tree Vulnerabilities}

Sparse Merkle Trees assign empty values to uninitialized leaves, enabling forged proofs.  
Binance Bridge was exploited through a manipulated AVL Merkle proof.  
Avoid custom cryptographic implementations unless formally verified.

\subsection{6. Front-running Attacks}

Miners reorder transactions by gas price.  

Example:
\begin{verbatim}
registerName("alice")
\end{verbatim}
An attacker sends:
\begin{verbatim}
registerName("alice") // higher gas price
\end{verbatim}

\textbf{Commit--Reveal Scheme} prevents this:
\begin{itemize}
    \item Commit: \texttt{hash(value, nonce)}
    \item Reveal later
    \item Verify hash
\end{itemize}

\subsection{7. Randomness Hazards}

Sources like \texttt{block.timestamp}, \texttt{block.number}, \texttt{blockhash}, \texttt{msg.sender} are predictable or miner-controlled.

Future blockhash is also insecure because miners can withhold or reorder blocks.

\textbf{Secure randomness: Commit--Reveal}.  
Both parties commit to random values, reveal later, then combine (e.g., XOR).  
If either party is honest, randomness is secure.

\subsection{8. Integer Overflow and Underflow}

Prior to Solidity~0.8, arithmetic did not include overflow checks.  
Example:
\begin{verbatim}
balance[msg.sender] -= value;
\end{verbatim}

Mitigation:
\begin{itemize}
    \item Use Solidity 0.8+ (automatic checks)
    \item Use SafeMath for older versions
\end{itemize}

\subsection{9. Gas Fairness}

Depending on contract design:
\begin{itemize}
    \item Last contributor may pay all gas
    \item Beneficiary may pay
    \item All parties may share costs
\end{itemize}

Fairness must be considered in crowdfunding or payout logic.

\subsection{10. Example of an Insecure Contract}

The Rock--Paper--Scissors example demonstrates:
\begin{itemize}
    \item Commit has no nonce, so the commitment \texttt{sha256(hand)} can be brute-forced (only 3 possibilities), letting an attacker discover the opponent's move before choosing their own.
    \item Anyone can call \texttt{open()}, meaning any account can reveal moves for players or manipulate when the game resolves.
    \item No deposit validation, so players can join without paying, and the contract incorrectly assumes it always holds exactly 1 ETH to pay the winner.
    \item \texttt{selfdestruct} sends all funds to the caller, allowing any user who triggers \texttt{open()} to steal the entire contract balance.
\end{itemize}


\end{document}
